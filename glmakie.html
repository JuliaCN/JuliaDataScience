<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US" xml:lang="en-US">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Jose Storopoli" />
  <meta name="author" content="Rik Huijzer" />
  <meta name="author" content="Lazaro Alonso" />
  <meta name="author" content="刘贵欣 (中文翻译)" />
  <meta name="author" content="田俊 （中文审校）" />
  <title>GLMakie.jl - Julia Data Science</title>
  <link rel="shortcut icon" type="image/png" href="/JuliaDataScience/favicon.png"/>
  <link rel="stylesheet" href="/JuliaDataScience/style.css"/>
    <script src="/JuliaDataScience/mousetrap.min.js"></script>
    <style>
  @font-face {
    font-family: JuliaMono-Regular;
    src: url("/JuliaDataScience/JuliaMono-Regular.woff2");
  }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>
  <link rel="stylesheet" href="/JuliaDataScience/github.min.css">
<script src="/JuliaDataScience/highlight.min.js"></script>
<script src="/JuliaDataScience/julia.min.js"></script>
<script>
document.addEventListener('DOMContentLoaded', (event) => {
    document.querySelectorAll('pre').forEach((el) => {
        hljs.highlightElement(el);
    });
});
</script>
 
</head>
<body>
<script>
function click_next() {
  var next = document.getElementById('nav-next');
  next.firstElementChild.nextElementSibling.click();
}
function click_prev() {
  var prev = document.getElementById('nav-prev');
  prev.firstElementChild.click();
}
Mousetrap.bind('right', click_next);
Mousetrap.bind('h', click_prev);
Mousetrap.bind('left', click_prev);
Mousetrap.bind('l', click_next);
</script>

<div class="books-container">
<aside class="books-menu">
<input type="checkbox" id="menu">
<label for="menu">☰</label>
<div class="books-title">
<a href="/JuliaDataScience/">Julia Data Science</a>
</div><br />
<span class="books-subtitle">

</span>
<div class="books-menu-content">
<li><a class="menu-level-1" href="/JuliaDataScience/preface"><b>1</b> 前言</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/why_data_science"><b>1.1</b> 什么是数据科学？</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/engineering"><b>1.2</b> 软件工程</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/acknowledgements"><b>1.3</b> 致谢</a></li>
<li><a class="menu-level-1" href="/JuliaDataScience/why_julia"><b>2</b> 为什么选择 Julia ?</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/non-programmers"><b>2.1</b> 从未编过程</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/programmers"><b>2.2</b> 有编程经验</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/julia_accomplish"><b>2.3</b> Julia 想实现什么?</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/julia_wild"><b>2.4</b> Julia 应用案例</a></li>
<li><a class="menu-level-1" href="/JuliaDataScience/julia_basics"><b>3</b> Julia 基础</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/ide"><b>3.1</b> 开发环境</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/syntax"><b>3.2</b> 语法</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/data_structures"><b>3.3</b> 原生数据结构</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/filesystem"><b>3.4</b> 文件系统</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/standardlibrary"><b>3.5</b> Julia 标准库</a></li>
<li><a class="menu-level-1" href="/JuliaDataScience/dataframes"><b>4</b> DataFrames.jl</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/load_save"><b>4.1</b> 加载和保存文件</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/index_summarize"><b>4.2</b> Index 和 Summarize</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/filter_subset"><b>4.3</b> Filter 和 Subset</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/select"><b>4.4</b> Select</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/missing_data"><b>4.5</b> 类型和缺失值</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/join"><b>4.6</b> Join</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/df_transform"><b>4.7</b> 变量变换</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/groupby_combine"><b>4.8</b> Groupby 和 Combine</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/df_performance"><b>4.9</b> 性能</a></li>
<li><a class="menu-level-1" href="/JuliaDataScience/DataVisualizationMakie"><b>5</b> 使用 Makie.jl 做数据可视化</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/cairomakie"><b>5.1</b> CairoMakie.jl</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/datavisMakie_attributes"><b>5.2</b> 属性</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/themes"><b>5.3</b> 主题</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/using_latex"><b>5.4</b> 使用 LaTeXStrings.jl</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/makie_colors"><b>5.5</b> 颜色和颜色图（Colormap）</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/makie_layouts"><b>5.6</b> 布局</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/glmakie"><b>5.7</b> GLMakie.jl</a></li>
<li><a class="menu-level-1" href="/JuliaDataScience/appendix"><b>6</b> 附录</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/appendix_pkg"><b>6.1</b> 库的版本</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/notation"><b>6.2</b> 符号</a></li>
<li><a class="menu-level-1" href="/JuliaDataScience/references"><b></b> 参考文献</a></li>
</div>
</aside>

<div class="books-content">
<h2 data-number="5.7" id="sec:glmakie"><span class="header-section-number">5.7</span> GLMakie.jl</h2>
<p><code>CairoMakie.jl</code> 满足了所有关于静态 2D 图的需求。 但除此之外，有时候还需要交互性，特别是在处理 3D 图的时候。 使用 3D 图可视化数据是 <strong>洞察</strong> 数据的常见做法。 这就是 <code>GLMakie.jl</code> 的用武之地，它使用 <a href="http://www.opengl.org/">OpenGL</a> 作为添加交互和响应功能的绘图后端。 与之前一样，一幅简单的图只包括线和点。因此，接下来将从简单图开始。因为已经知道布局如何使用，所以将在例子中应用一些布局。</p>
<h3 data-number="5.7.1" id="散点图和折线图"><span class="header-section-number">5.7.1</span> 散点图和折线图</h3>
<p>散点图有两种绘制选项，第一种是 <code>scatter(x, y, z)</code>，另一种是 <code>meshscatter(x, y, z)</code>。 若使用第一种，标记则不会沿着坐标轴缩放，但在使用第二种时标记会缩放， 这是因为此时它们是三维空间的几何实体。 例子如下：</p>
<pre><code>using GLMakie
GLMakie.activate!()</code></pre>
<pre class="language-julia"><code>function scatters_in_3D()
    seed!(123)
    xyz = randn(10, 3)
    x, y, z = xyz[:, 1], xyz[:, 2], xyz[:, 3]
    fig = Figure(resolution=(1600, 400))
    ax1 = Axis3(fig[1, 1]; aspect=(1, 1, 1), perspectiveness=0.5)
    ax2 = Axis3(fig[1, 2]; aspect=(1, 1, 1), perspectiveness=0.5)
    ax3 = Axis3(fig[1, 3]; aspect=:data, perspectiveness=0.5)
    scatter!(ax1, x, y, z; markersize=50)
    meshscatter!(ax2, x, y, z; markersize=0.25)
    hm = meshscatter!(ax3, x, y, z; markersize=0.25,
        marker=FRect3D(Vec3f(0), Vec3f(1)), color=1:size(xyz)[2],
        colormap=:plasma, transparency=false)
    Colorbar(fig[1, 4], hm, label=&quot;values&quot;, height=Relative(0.5))
    fig
end
scatters_in_3D()</code></pre>
<figure>
<img src="/JuliaDataScience/im/JDS_scatters_in_3D_.png" id="fig:scatters_in_3D" alt="Figure 36: Scatters in 3D." /><figcaption aria-hidden="true">Figure 36: Scatters in 3D.</figcaption>
</figure>
<p>另请注意，标记可以是不同的几何实体，比如正方形或矩形。另外，也可以为标记设置 <code>colormap</code>。 对于上面位于中间的 3D 图，如果想得到获得完美的球体，那么只需如右侧图那样添加 <code>aspect = :data</code> 参数。 绘制 <code>lines</code> 或 <code>scatterlines</code> 也很简单：</p>
<pre class="language-julia"><code>function lines_in_3D()
    seed!(123)
    xyz = randn(10, 3)
    x, y, z = xyz[:, 1], xyz[:, 2], xyz[:, 3]
    fig = Figure(resolution=(1600, 400))
    ax1 = Axis3(fig[1, 1]; aspect=(1, 1, 1), perspectiveness=0.5)
    ax2 = Axis3(fig[1, 2]; aspect=(1, 1, 1), perspectiveness=0.5)
    ax3 = Axis3(fig[1, 3]; aspect=:data, perspectiveness=0.5)
    lines!(ax1, x, y, z; color=1:size(xyz)[2], linewidth=3)
    scatterlines!(ax2, x, y, z; markersize=50)
    hm = meshscatter!(ax3, x, y, z; markersize=0.2, color=1:size(xyz)[2])
    lines!(ax3, x, y, z; color=1:size(xyz)[2])
    Colorbar(fig[2, 1], hm; label=&quot;values&quot;, height=15, vertical=false,
        flipaxis=false, ticksize=15, tickalign=1, width=Relative(3.55 / 4))
    fig
end
lines_in_3D()</code></pre>
<figure>
<img src="/JuliaDataScience/im/JDS_lines_in_3D_.png" id="fig:lines_in_3D" alt="Figure 37: Lines in 3D." /><figcaption aria-hidden="true">Figure 37: Lines in 3D.</figcaption>
</figure>
<p>在 3D 图中绘制 <code>surface</code>， <code>wireframe</code> 和 <code>contour</code> 是一项容易的工作。</p>
<h3 data-number="5.7.2" id="surfacewireframecontourcontourf-和-contour3d"><span class="header-section-number">5.7.2</span> <code>surface</code>，<code>wireframe</code>，<code>contour</code>，<code>contourf</code> 和 <code>contour3d</code></h3>
<p>将使用如下的 <code>peaks</code> 函数展示这些例子：</p>
<pre class="language-julia"><code>function peaks(; n=49)
    x = LinRange(-3, 3, n)
    y = LinRange(-3, 3, n)
    a = 3 * (1 .- x&#39;) .^ 2 .* exp.(-(x&#39; .^ 2) .- (y .+ 1) .^ 2)
    b = 10 * (x&#39; / 5 .- x&#39; .^ 3 .- y .^ 5) .* exp.(-x&#39; .^ 2 .- y .^ 2)
    c = 1 / 3 * exp.(-(x&#39; .+ 1) .^ 2 .- y .^ 2)
    return (x, y, a .- b .- c)
end</code></pre>
<p>不同绘图函数的输出如下：</p>
<pre class="language-julia"><code>function plot_peaks_function()
    x, y, z = peaks()
    x2, y2, z2 = peaks(; n=15)
    fig = Figure(resolution=(1600, 400), fontsize=26)
    axs = [Axis3(fig[1, i]; aspect=(1, 1, 1)) for i = 1:3]
    hm = surface!(axs[1], x, y, z)
    wireframe!(axs[2], x2, y2, z2)
    contour3d!(axs[3], x, y, z; levels=20)
    Colorbar(fig[1, 4], hm, height=Relative(0.5))
    fig
end
plot_peaks_function()</code></pre>
<figure>
<img src="/JuliaDataScience/im/JDS_plot_peaks_function_.png" id="fig:plot_peaks_function" alt="Figure 38: Plot peaks function." /><figcaption aria-hidden="true">Figure 38: Plot peaks function.</figcaption>
</figure>
<p>但是也可以使用 <code>heatmap(x, y, z)</code>，<code>contour(x, y, z)</code> 或 <code>contourf(x, y, z)</code> 绘图：</p>
<pre class="language-julia"><code>function heatmap_contour_and_contourf()
    x, y, z = peaks()
    fig = Figure(resolution=(1600, 400), fontsize=26)
    axs = [Axis(fig[1, i]; aspect=DataAspect()) for i = 1:3]
    hm = heatmap!(axs[1], x, y, z)
    contour!(axs[2], x, y, z; levels=20)
    contourf!(axs[3], x, y, z)
    Colorbar(fig[1, 4], hm, height=Relative(0.5))
    fig
end
heatmap_contour_and_contourf()</code></pre>
<figure>
<img src="/JuliaDataScience/im/JDS_heatmap_contour_and_contourf_.png" id="fig:heatmap_contour_and_contourf" alt="Figure 39: Heatmap contour and contourf." /><figcaption aria-hidden="true">Figure 39: Heatmap contour and contourf.</figcaption>
</figure>
<p>另外，只要将<code>Axis</code> 更改为 <code>Axis3</code>，这些图就会自动位于 x-y 平面：</p>
<pre class="language-julia"><code>function heatmap_contour_and_contourf_in_a_3d_plane()
    x, y, z = peaks()
    fig = Figure(resolution=(1600, 400), fontsize=26)
    axs = [Axis3(fig[1, i]) for i = 1:3]
    hm = heatmap!(axs[1], x, y, z)
    contour!(axs[2], x, y, z; levels=20)
    contourf!(axs[3], x, y, z)
    Colorbar(fig[1, 4], hm, height=Relative(0.5))
    fig
end
heatmap_contour_and_contourf_in_a_3d_plane()</code></pre>
<figure>
<img src="/JuliaDataScience/im/JDS_heatmap_contour_and_contourf_in_a_3d_plane_.png" id="fig:heatmap_contour_and_contourf_in_a_3d_plane" alt="Figure 40: Heatmap contour and contourf in a 3d plane." /><figcaption aria-hidden="true">Figure 40: Heatmap contour and contourf in a 3d plane.</figcaption>
</figure>
<p>将这些绘图函数混合在一起也是非常简单的，如下所示：</p>
<pre><code>using TestImages</code></pre>
<pre class="language-julia"><code>function mixing_surface_contour3d_contour_and_contourf()
    img = testimage(&quot;coffee.png&quot;)
    x, y, z = peaks()
    cmap = :Spectral_11
    fig = Figure(resolution=(1200, 800), fontsize=26)
    ax1 = Axis3(fig[1, 1]; aspect=(1, 1, 1), elevation=pi / 6, xzpanelcolor=(:black, 0.75),
        perspectiveness=0.5, yzpanelcolor=:black, zgridcolor=:grey70,
        ygridcolor=:grey70, xgridcolor=:grey70)
    ax2 = Axis3(fig[1, 3]; aspect=(1, 1, 1), elevation=pi / 6, perspectiveness=0.5)
    hm = surface!(ax1, x, y, z; colormap=(cmap, 0.95), shading=true)
    contour3d!(ax1, x, y, z .+ 0.02; colormap=cmap, levels=20, linewidth=2)
    xmin, ymin, zmin = minimum(ax1.finallimits[])
    xmax, ymax, zmax = maximum(ax1.finallimits[])
    contour!(ax1, x, y, z; colormap=cmap, levels=20, transformation=(:xy, zmax))
    contourf!(ax1, x, y, z; colormap=cmap, transformation=(:xy, zmin))
    Colorbar(fig[1, 2], hm, width=15, ticksize=15, tickalign=1, height=Relative(0.35))
    # transformations into planes
    heatmap!(ax2, x, y, z; colormap=:viridis, transformation=(:yz, 3.5))
    contourf!(ax2, x, y, z; colormap=:CMRmap, transformation=(:xy, -3.5))
    contourf!(ax2, x, y, z; colormap=:bone_1, transformation=(:xz, 3.5))
    image!(ax2, -3 .. 3, -3 .. 2, rotr90(img); transformation=(:xy, 3.8))
    xlims!(ax2, -3.8, 3.8)
    ylims!(ax2, -3.8, 3.8)
    zlims!(ax2, -3.8, 3.8)
    fig
end
mixing_surface_contour3d_contour_and_contourf()</code></pre>
<figure>
<img src="/JuliaDataScience/im/JDS_mixing_surface_contour3d_contour_and_contourf_.png" id="fig:mixing_surface_contour3d_contour_and_contourf" style="width:60.0%" alt="Figure 41: Mixing surface, contour3d, contour and contourf." /><figcaption aria-hidden="true">Figure 41: Mixing surface, contour3d, contour and contourf.</figcaption>
</figure>
<p>还不错，对吧？从这里也可以看出，任何的 <code>heatmap</code>， <code>contour</code>，<code>contourf</code> 和 <code>image</code> 都可以绘制在任何平面上。</p>
<h3 data-number="5.7.3" id="arrows-和-streamplot"><span class="header-section-number">5.7.3</span> <code>arrows</code> 和 <code>streamplot</code></h3>
<p>当想要知道给定变量的方向时，<code>arrows</code> 和 <code>streamplot</code> 会变得非常有用。 参见如下的示例<a href="/JuliaDataScience#fn18" class="footnote-ref" id="fnref18" role="doc-noteref"><sup>18</sup></a>：</p>
<pre><code>using LinearAlgebra</code></pre>
<pre class="language-julia"><code>function arrows_and_streamplot_in_3d()
    ps = [Point3f(x, y, z) for x = -3:1:3 for y = -3:1:3 for z = -3:1:3]
    ns = map(p -&gt; 0.1 * rand() * Vec3f(p[2], p[3], p[1]), ps)
    lengths = norm.(ns)
    flowField(x, y, z) = Point(-y + x * (-1 + x^2 + y^2)^2, x + y * (-1 + x^2 + y^2)^2,
        z + x * (y - z^2))
    fig = Figure(resolution=(1200, 800), fontsize=26)
    axs = [Axis3(fig[1, i]; aspect=(1, 1, 1), perspectiveness=0.5) for i = 1:2]
    arrows!(axs[1], ps, ns, color=lengths, arrowsize=Vec3f0(0.2, 0.2, 0.3),
        linewidth=0.1)
    streamplot!(axs[2], flowField, -4 .. 4, -4 .. 4, -4 .. 4, colormap=:plasma,
        gridsize=(7, 7), arrow_size=0.25, linewidth=1)
    fig
end
arrows_and_streamplot_in_3d()</code></pre>
<figure>
<img src="/JuliaDataScience/im/JDS_arrows_and_streamplot_in_3d_.png" id="fig:arrows_and_streamplot_in_3d" style="width:60.0%" alt="Figure 42: Arrows and streamplot in 3d." /><figcaption aria-hidden="true">Figure 42: Arrows and streamplot in 3d.</figcaption>
</figure>
<p>另外一些有趣的例子是 <code>mesh(obj)</code>，<code>volume(x, y, z, vals)</code> 和 <code>contour(x, y, z, vals)</code>。</p>
<h3 data-number="5.7.4" id="mesh-和-volume"><span class="header-section-number">5.7.4</span> <code>mesh</code> 和 <code>volume</code></h3>
<p>绘制网格在想要画出几何实体时很有用，例如 <code>Sphere</code> 或矩形这样的几何实体，即 <code>FRect3D</code>。 另一种在 3D 空间中可视化的方法是调用 <code>volume</code> 和 <code>contour</code> 函数，它们通过实现 <a href="https://en.wikipedia.org/wiki/Ray_tracing_(graphics)">光线追踪</a> 来模拟各种光学效果。 例子如下：</p>
<pre><code>using GeometryBasics</code></pre>
<pre class="language-julia"><code>function mesh_volume_contour()
    # mesh objects
    rectMesh = FRect3D(Vec3f(-0.5), Vec3f(1))
    recmesh = GeometryBasics.mesh(rectMesh)
    sphere = Sphere(Point3f(0), 1)
    # https://juliageometry.github.io/GeometryBasics.jl/stable/primitives/
    spheremesh = GeometryBasics.mesh(Tesselation(sphere, 64))
    # uses 64 for tesselation, a smoother sphere
    colors = [rand() for v in recmesh.position]
    # cloud points for volume
    x = y = z = 1:10
    vals = randn(10, 10, 10)
    fig = Figure(resolution=(1600, 400))
    axs = [Axis3(fig[1, i]; aspect=(1, 1, 1), perspectiveness=0.5) for i = 1:3]
    mesh!(axs[1], recmesh; color=colors, colormap=:rainbow, shading=false)
    mesh!(axs[1], spheremesh; color=(:white, 0.25), transparency=true)
    volume!(axs[2], x, y, z, vals; colormap=Reverse(:plasma))
    contour!(axs[3], x, y, z, vals; colormap=Reverse(:plasma))
    fig
end
mesh_volume_contour()</code></pre>
<figure>
<img src="/JuliaDataScience/im/JDS_mesh_volume_contour_.png" id="fig:mesh_volume_contour" alt="Figure 43: Mesh volume contour." /><figcaption aria-hidden="true">Figure 43: Mesh volume contour.</figcaption>
</figure>
<p>注意到透明球和立方体绘制在同一个坐标系中。 截至目前，我们已经包含了 3D 绘图的大多数用例。 另一个例子是 <code>?linesegments</code>。</p>
<p>参考之前的例子，可以使用球体和矩形平面创建一些自定义图：</p>
<pre><code>using GeometryBasics, Colors</code></pre>
<p>首先为球体定义一个矩形网格，而且给每个球定义不同的颜色。 另外，可以将球体和平面混合在一张图里。下面的代码定义了所有必要的数据。</p>
<pre class="language-julia"><code>seed!(123)
spheresGrid = [Point3f(i,j,k) for i in 1:2:10 for j in 1:2:10 for k in 1:2:10]
colorSphere = [RGBA(i * 0.1, j * 0.1, k * 0.1, 0.75) for i in 1:2:10 for j in 1:2:10 for k in 1:2:10]
spheresPlane = [Point3f(i,j,k) for i in 1:2.5:20 for j in 1:2.5:10 for k in 1:2.5:4]
cmap = get(colorschemes[:plasma], LinRange(0, 1, 50))
colorsPlane = cmap[rand(1:50,50)]
rectMesh = FRect3D(Vec3f(-1, -1, 2.1), Vec3f(22, 11, 0.5))
recmesh = GeometryBasics.mesh(rectMesh)
colors = [RGBA(rand(4)...) for v in recmesh.position]</code></pre>
<p>然后可使用如下方式简单地绘图：</p>
<pre class="language-julia"><code>function grid_spheres_and_rectangle_as_plate()
    fig = with_theme(theme_dark()) do
        fig = Figure(resolution=(1200, 800))
        ax1 = Axis3(fig[1, 1]; aspect=:data, perspectiveness=0.5, azimuth=0.72)
        ax2 = Axis3(fig[1, 2]; aspect=:data, perspectiveness=0.5)
        meshscatter!(ax1, spheresGrid; color = colorSphere, markersize = 1,
            shading=false)
        meshscatter!(ax2, spheresPlane; color=colorsPlane, markersize = 0.75,
            lightposition=Vec3f(10, 5, 2), ambient=Vec3f(0.95, 0.95, 0.95),
            backlight=1.0f0)
        mesh!(recmesh; color=colors, colormap=:rainbow, shading=false)
        limits!(ax1, 0, 10, 0, 10, 0, 10)
        fig
    end
    fig
end
grid_spheres_and_rectangle_as_plate()</code></pre>
<figure>
<img src="/JuliaDataScience/im/JDS_grid_spheres_and_rectangle_as_plate_.png" id="fig:grid_spheres_and_rectangle_as_plate" style="width:60.0%" alt="Figure 44: Grid spheres and rectangle as plate." /><figcaption aria-hidden="true">Figure 44: Grid spheres and rectangle as plate.</figcaption>
</figure>
<p>注意，右侧图中的矩形平面是半透明的，这是因为颜色函数 <code>RGBA()</code> 中定义了 <code>alpha</code> 参数。 矩形函数是通用的，因此很容易用来实现 3D 方块，而它又能用于绘制 3D 直方图。 参见如下的例子，我们将再次使用 <code>peaks</code> 函数并增加一些定义：</p>
<pre class="language-julia"><code>x, y, z = peaks(; n=15)
δx = (x[2] - x[1]) / 2
δy = (y[2] - y[1]) / 2
cbarPal = :Spectral_11
ztmp = (z .- minimum(z)) ./ (maximum(z .- minimum(z)))
cmap = get(colorschemes[cbarPal], ztmp)
cmap2 = reshape(cmap, size(z))
ztmp2 = abs.(z) ./ maximum(abs.(z)) .+ 0.15</code></pre>
<p>其中方块的尺寸由 <span class="math inline">\(\delta x, \delta y\)</span> 指定。 <code>cmap2</code> 用于指定每个方块的颜色而 <code>ztmp2</code> 用于指定每个方块的透明度。如下图所示。</p>
<pre class="language-julia"><code>function histogram_or_bars_in_3d()
    fig = Figure(resolution=(1200, 800), fontsize=26)
    ax1 = Axis3(fig[1, 1]; aspect=(1, 1, 1), elevation=π/6,
        perspectiveness=0.5)
    ax2 = Axis3(fig[1, 2]; aspect=(1, 1, 1), perspectiveness=0.5)
    rectMesh = FRect3D(Vec3f0(-0.5, -0.5, 0), Vec3f0(1, 1, 1))
    meshscatter!(ax1, x, y, 0*z, marker = rectMesh, color = z[:],
        markersize = Vec3f.(2δx, 2δy, z[:]), colormap = :Spectral_11,
        shading=false)
    limits!(ax1, -3.5, 3.5, -3.5, 3.5, -7.45, 7.45)
    meshscatter!(ax2, x, y, 0*z, marker = rectMesh, color = z[:],
        markersize = Vec3f.(2δx, 2δy, z[:]), colormap = (:Spectral_11, 0.25),
        shading=false, transparency=true)
    for (idx, i) in enumerate(x), (idy, j) in enumerate(y)
        rectMesh = FRect3D(Vec3f(i - δx, j - δy, 0), Vec3f(2δx, 2δy, z[idx, idy]))
        recmesh = GeometryBasics.mesh(rectMesh)
        lines!(ax2, recmesh; color=(cmap2[idx, idy], ztmp2[idx, idy]))
    end
    fig
end
histogram_or_bars_in_3d()</code></pre>
<figure>
<img src="/JuliaDataScience/im/JDS_histogram_or_bars_in_3d_.png" id="fig:histogram_or_bars_in_3d" style="width:60.0%" alt="Figure 45: Histogram or bars in 3d." /><figcaption aria-hidden="true">Figure 45: Histogram or bars in 3d.</figcaption>
</figure>
<p>应注意到，也可以在 <code>mesh</code> 对象上调用 <code>lines</code> 或 <code>wireframe</code>。</p>
<h3 data-number="5.7.5" id="填充的线和带"><span class="header-section-number">5.7.5</span> 填充的线和带</h3>
<p>在最终的例子中， 我们将展示如何使用 <code>band</code>和一些 <code>linesegments</code> 填充 3D 图中的曲线：</p>
<pre class="language-julia"><code>function filled_line_and_linesegments_in_3D()
    xs = LinRange(-3, 3, 10)
    lower = [Point3f(i, -i, 0) for i in LinRange(0, 3, 100)]
    upper = [Point3f(i, -i, sin(i) * exp(-(i + i))) for i in range(0, 3, length=100)]
    fig = Figure(resolution=(1200, 800))
    axs = [Axis3(fig[1, i]; elevation=pi/6, perspectiveness=0.5) for i = 1:2]
    band!(axs[1], lower, upper, color=repeat(norm.(upper), outer=2), colormap=:CMRmap)
    lines!(axs[1], upper, color=:black)
    linesegments!(axs[2], cos.(xs), xs, sin.(xs), linewidth=5, color=1:length(xs))
    fig
end
filled_line_and_linesegments_in_3D()</code></pre>
<figure>
<img src="/JuliaDataScience/im/JDS_filled_line_and_linesegments_in_3D_.png" id="fig:filled_line_and_linesegments_in_3D" style="width:60.0%" alt="Figure 46: Filled line and linesegments in 3D." /><figcaption aria-hidden="true">Figure 46: Filled line and linesegments in 3D.</figcaption>
</figure>
<p>最后，我们的3D绘图之旅到此结束。 你可以将我们这里展示的一切结合起来，去创造令人惊叹的 3D 图！</p>


<div class="bottom-nav">
    <p id="nav-prev" style="text-align: left;">
        <a class="menu-level-2" href="/JuliaDataScience/makie_layouts"><b>5.6</b> 布局</a> <kbd>←</kbd>
        <span id="nav-next" style="float: right;">
            <kbd>→</kbd> <a class="menu-level-1" href="/JuliaDataScience/appendix"><b>6</b> 附录</a>
        </span>
    </p>
</div>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn18" role="doc-endnote"><p> 18. 此处使用 Julia 标准库中的 <code>LinearAlgebra</code>。<a href="/JuliaDataScience#fnref18" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>


<div class="license">
    <br/>
  <br/>
  <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a>
    Jose Storopoli, Rik Huijzer, Lazaro Alonso, 刘贵欣 (中文翻译), 田俊 （中文审校）
</div>
</div>
</div>
</body>
</html>