<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US" xml:lang="en-US">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Jose Storopoli" />
  <meta name="author" content="Rik Huijzer" />
  <meta name="author" content="Lazaro Alonso" />
  <meta name="author" content="刘贵欣 (中文翻译)" />
  <meta name="author" content="田俊 （中文审校）" />
  <title>性能 - Julia Data Science</title>
  <link rel="shortcut icon" type="image/png" href="/JuliaDataScience/favicon.png"/>
  <link rel="stylesheet" href="/JuliaDataScience/style.css"/>
    <script src="/JuliaDataScience/mousetrap.min.js"></script>
    <style>
  @font-face {
    font-family: JuliaMono-Regular;
    src: url("/JuliaDataScience/JuliaMono-Regular.woff2");
  }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>
  <link rel="stylesheet" href="/JuliaDataScience/github.min.css">
<script src="/JuliaDataScience/highlight.min.js"></script>
<script src="/JuliaDataScience/julia.min.js"></script>
<script>
document.addEventListener('DOMContentLoaded', (event) => {
    document.querySelectorAll('pre').forEach((el) => {
        hljs.highlightElement(el);
    });
});
</script>
 
</head>
<body>
<script>
function click_next() {
  var next = document.getElementById('nav-next');
  next.firstElementChild.nextElementSibling.click();
}
function click_prev() {
  var prev = document.getElementById('nav-prev');
  prev.firstElementChild.click();
}
Mousetrap.bind('right', click_next);
Mousetrap.bind('h', click_prev);
Mousetrap.bind('left', click_prev);
Mousetrap.bind('l', click_next);
</script>

<div class="books-container">
<aside class="books-menu">
<input type="checkbox" id="menu">
<label for="menu">☰</label>
<div class="books-title">
<a href="/JuliaDataScience/">Julia Data Science</a>
</div><br />
<span class="books-subtitle">

</span>
<div class="books-menu-content">
<li><a class="menu-level-1" href="/JuliaDataScience/preface"><b>1</b> 前言</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/why_data_science"><b>1.1</b> 什么是数据科学？</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/engineering"><b>1.2</b> 软件工程</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/acknowledgements"><b>1.3</b> 致谢</a></li>
<li><a class="menu-level-1" href="/JuliaDataScience/why_julia"><b>2</b> 为什么选择 Julia ?</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/non-programmers"><b>2.1</b> 从未编过程</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/programmers"><b>2.2</b> 有编程经验</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/julia_accomplish"><b>2.3</b> Julia 想实现什么?</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/julia_wild"><b>2.4</b> Julia 应用案例</a></li>
<li><a class="menu-level-1" href="/JuliaDataScience/julia_basics"><b>3</b> Julia 基础</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/ide"><b>3.1</b> 开发环境</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/syntax"><b>3.2</b> 语法</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/data_structures"><b>3.3</b> 原生数据结构</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/filesystem"><b>3.4</b> 文件系统</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/standardlibrary"><b>3.5</b> Julia 标准库</a></li>
<li><a class="menu-level-1" href="/JuliaDataScience/dataframes"><b>4</b> DataFrames.jl</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/load_save"><b>4.1</b> 加载和保存文件</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/index_summarize"><b>4.2</b> Index 和 Summarize</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/filter_subset"><b>4.3</b> Filter 和 Subset</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/select"><b>4.4</b> Select</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/missing_data"><b>4.5</b> 类型和缺失值</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/join"><b>4.6</b> Join</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/df_transform"><b>4.7</b> 变量变换</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/groupby_combine"><b>4.8</b> Groupby 和 Combine</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/df_performance"><b>4.9</b> 性能</a></li>
<li><a class="menu-level-1" href="/JuliaDataScience/DataVisualizationMakie"><b>5</b> 使用 Makie.jl 做数据可视化</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/cairomakie"><b>5.1</b> CairoMakie.jl</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/datavisMakie_attributes"><b>5.2</b> 属性</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/themes"><b>5.3</b> 主题</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/using_latex"><b>5.4</b> 使用 LaTeXStrings.jl</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/makie_colors"><b>5.5</b> 颜色和颜色图（Colormap）</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/makie_layouts"><b>5.6</b> 布局</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/glmakie"><b>5.7</b> GLMakie.jl</a></li>
<li><a class="menu-level-1" href="/JuliaDataScience/appendix"><b>6</b> 附录</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/appendix_pkg"><b>6.1</b> 库的版本</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/notation"><b>6.2</b> 符号</a></li>
<li><a class="menu-level-1" href="/JuliaDataScience/references"><b></b> 参考文献</a></li>
</div>
</aside>

<div class="books-content">
<h2 data-number="4.9" id="sec:df_performance"><span class="header-section-number">4.9</span> 性能</h2>
<p>截至目前，我们还没有尝试让 <code>DataFrames.jl</code> 代码变得 <strong>快些</strong>。 就像 Julia 中的一切， <code>DataFrames.jl</code> 实际上也可以变得非常快。 本节将给出一些性能建议和技巧。</p>
<h3 data-number="4.9.1" id="sec:df_performance_inplace"><span class="header-section-number">4.9.1</span> In-place 的操作</h3>
<p>如在 Section <a href="/JuliaDataScience/data_structures#sec:function_bang">3.3.2</a> 讨论的那样，如果函数结尾带有叹号 <code>!</code>，那么这表明该函数会更改传入的参数。 在 Julia 高性能代码的语境中，这<strong>表明</strong> 带有 <code>!</code>的函数将会原地（in-place）修改我们传入的参数对象。</p>
<p>几乎所有的 <code>DataFrames.jl</code> 函数都有一个带 <code>!</code> 的版本。 例如， <code>filter</code> 有 <em>in-place</em> 的 <code>filter!</code>， <code>select</code> 有 <code>select!</code>， <code>subset</code> 有 <code>subset!</code> 等等。 注意，这些函数都 <strong>没有</strong> 返回新的 <code>DataFrame</code>，而是直接 <strong>更新</strong> 传入的 <code>DataFrame</code> 。 另外， <code>DataFrames.jl</code> (从版本 1.3 开始)支持 in-place 的 <code>leftjoin</code> ，即 <code>leftjoin!</code> 函数。 该函数会使用右侧 <code>DataFrame</code> 的数据列更新左侧 <code>DataFrame</code> 。 需要注意的是，左表的每一行 <strong>最多</strong> 只能匹配右表中的一行。</p>
<p>如果想在代码中获得最高的速度和性能，你绝对应该使用带 <code>!</code> 的函数，而不是常规的 <code>DataFrames.jl</code> 函数。</p>
<p>让我们回到在 Section <a href="/JuliaDataScience/select#sec:select">4.4</a> 开始部分提到的关于 <code>select</code> 函数的例子。 如下是 <code>responses</code> 的 <code>DataFrame</code>：</p>
<pre class="language-julia"><code>responses()</code></pre>
<table>
<thead>
<tr class="header">
<th style="text-align: right;">id</th>
<th style="text-align: right;">q1</th>
<th style="text-align: right;">q2</th>
<th style="text-align: right;">q3</th>
<th style="text-align: right;">q4</th>
<th style="text-align: right;">q5</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">1</td>
<td style="text-align: right;">28</td>
<td style="text-align: right;">us</td>
<td style="text-align: right;">F</td>
<td style="text-align: right;">B</td>
<td style="text-align: right;">A</td>
</tr>
<tr class="even">
<td style="text-align: right;">2</td>
<td style="text-align: right;">61</td>
<td style="text-align: right;">fr</td>
<td style="text-align: right;">B</td>
<td style="text-align: right;">C</td>
<td style="text-align: right;">E</td>
</tr>
</tbody>
</table>
<p>现在使用 <code>select</code> 函数来进行选择，就像之前所做的那样：</p>
<pre class="language-julia"><code>select(responses(), :id, :q1)</code></pre>
<table>
<thead>
<tr class="header">
<th style="text-align: right;">id</th>
<th style="text-align: right;">q1</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">1</td>
<td style="text-align: right;">28</td>
</tr>
<tr class="even">
<td style="text-align: right;">2</td>
<td style="text-align: right;">61</td>
</tr>
</tbody>
</table>
<p>而 <em>in-place</em> 函数如下：</p>
<pre class="language-julia"><code>select!(responses(), :id, :q1)</code></pre>
<table>
<thead>
<tr class="header">
<th style="text-align: right;">id</th>
<th style="text-align: right;">q1</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">1</td>
<td style="text-align: right;">28</td>
</tr>
<tr class="even">
<td style="text-align: right;">2</td>
<td style="text-align: right;">61</td>
</tr>
</tbody>
</table>
<p><code>@allocated</code> 宏会告诉我们运行过程中分配的内存大小。 换句话说，<strong>计算机在运行代码时需要在内存中存储多少新信息</strong>。 让我们看看运行结果：</p>
<pre class="language-julia"><code>df = responses()
@allocated select(df, :id, :q1)</code></pre>
<pre class="language-plain"><code>6976</code></pre>
<pre class="language-julia"><code>df = responses()
@allocated select!(df, :id, :q1)</code></pre>
<pre class="language-plain"><code>6752</code></pre>
<p>如我们所看到的那样， <code>select!</code> 分配的内存小于 <code>select</code> 的。 所以，由于消耗更少的内存，它应该更快。</p>
<h3 data-number="4.9.2" id="sec:df_performance_df_copy"><span class="header-section-number">4.9.2</span> 复制或者不复制列</h3>
<p>有两种 <strong>访问 DataFrame 列</strong>的方式。 它们的不同之处在于：一种方式是创建列的 “view”，并且没有拷贝；而另一种方式是从原始列复制出一个全新的列。</p>
<p>第一种方式通常使用点运算符 <code>.</code> + 列名的语法，即 <code>df.col</code>。 这种方式 <strong>不拷贝</strong> 列 <code>col</code>。 实际上，<code>df.col</code> 创建了链接到原始列的 “view” ，且没有分配任何内存。 另外，<code>df.col</code> 语法等价于带有 <code>i</code> 的列选择器 <code>df[!, :col]</code> 。</p>
<p>第二种访问 <code>DataFrame</code> 列的方式是 <code>df[:, :col]</code>，即使用 <code>:</code> 作为列选择器。 这种方式 <strong>会拷贝</strong> 列 <code>col</code>， 所以请注意这将产生非预期的内存分配。</p>
<p>与之前一样， 让我们尝试这两种方法来访问 <code>DataFrame</code> <code>responses</code> 中的列：</p>
<pre class="language-julia"><code>df = responses()
@allocated col = df[:, :id]</code></pre>
<pre class="language-plain"><code>572174</code></pre>
<pre class="language-julia"><code>df = responses()
@allocated col = df[!, :id]</code></pre>
<pre class="language-plain"><code>0</code></pre>
<p>当访问某列而不复制它时，不会进行任何内存分配，代码应该更快。 所以，如果不需要复制，通常请使用 <code>df.col</code> 或 <code>df[!, :col]</code> 访问 <code>DataFrame</code> 的列， 而不是 <code>df[:, :col]</code>。</p>
<h3 data-number="4.9.3" id="sec:df_performance_csv_read_file"><span class="header-section-number">4.9.3</span> CSV.read 和 CSV.File</h3>
<p>如果查看过 <code>CSV.read</code> 的帮助输出， 你将会发现一个与该函数功能等价的便利函数 <code>CSV.File</code>，它们拥有相同的关键字参数。 <code>CSV.read</code> 和 <code>CSV.File</code> 都可以用来读取 CSV 文件的内容，但它们的默认行为不同。 <strong>在默认情况下，<code>CSV.read</code> 不会复制</strong> 输入数据。 取而代之的是，<code>CSV.read</code> 会把所有数据传入第二个参数（称为“槽”）。</p>
<p>因此如下所示：</p>
<pre class="julia"><code>df = CSV.read(&quot;file.csv&quot;, DataFrame)</code></pre>
<p>这将会把 <code>file.csv</code> 中的数据传入 <code>DataFrame</code> 槽， 然后把 <code>DataFrame</code> 类型返回给 <code>df</code> 变量。</p>
<p>在 <code>CSV.File</code> 的例子中，<strong>情况相反：默认情况下，它将会复制 CSV 文件中的每一列</strong>。 另外，语法上也稍有不同。 我们需要将 <code>CSV.File</code> 返回的所有数据包含在 <code>DataFrame</code> 构造器函数：</p>
<pre class="julia"><code>df = DataFrame(CSV.File(&quot;file.csv&quot;))</code></pre>
<p>或者，也可以使用 <code>|&gt;</code> 管道运算符：</p>
<pre class="julia"><code>df = CSV.File(&quot;file.csv&quot;) |&gt; DataFrame</code></pre>
<p>如之前所说， <code>CSV.File</code> 将会复制 CSV 文件中的每一列。 因此，如果想要最佳性能，那么肯定应该使用 <code>CSV.read</code> 而不是 <code>CSV.File</code>。 这就是为什么 在 Section <a href="/JuliaDataScience/load_save#sec:csv">4.1.1</a> 中只讨论 <code>CSV.read</code>。</p>
<h3 data-number="4.9.4" id="sec:df_performance_csv_multiple"><span class="header-section-number">4.9.4</span> CSV.jl 与多文件</h3>
<p>现在让我们关注 <code>CSV.jl</code>。 特别要关注将多个 CSV 文件读取到一个 <code>DataFrame</code> 的例子。 从 <code>CSV.jl</code> 的 0.9 版本开始， 我们可以提供文件名字符串的向量。 在此之前，用户需要按顺序读取多个文件，并将它们垂直连接到单个 <code>DataFrame</code> 中。 举个例子，下面的代码将读取多个 CSV 文件，并使用 <code>vcat</code> 和 <code>reduce</code> 函数将它们垂直连接到单个 <code>DataFrame</code> 中：</p>
<pre class="julia"><code>files = filter(endswith(&quot;.csv&quot;), readdir())
df = reduce(vcat, CSV.read(file, DataFrame) for file in files)</code></pre>
<p>一个附加的特点是，<code>reduce</code> 不能并行化，因为它必须遵循与 <code>files</code>向量相同的顺序。</p>
<p>若在 <code>CSV.jl</code> 使用该功能，则可以简单地向 <code>CSV.read</code> 函数传入 <code>files</code> 向量：</p>
<pre class="julia"><code>files = filter(endswith(&quot;.csv&quot;), readdir())
df = CSV.read(files, DataFrame)</code></pre>
<p><code>CSV.jl</code> 将会为每个文件单独指定一个计算机中可用的线程，然后将每个线程的的输出延迟连接到 <code>DataFrame</code> 中。 因此，在不使用 <code>reduce</code> 函数时，我们获得了 <strong>额外的多线程优点</strong>。</p>
<h3 data-number="4.9.5" id="sec:df_performance_categorical_compression"><span class="header-section-number">4.9.5</span> CategoricalArrays.jl 压缩</h3>
<p>如果需要处理大量的分类值，例如许多代表不同定性数据的文本数据列，那么可能需要使用 <code>CategoricalArrays.jl</code> 压缩来处理此类情况。</p>
<p>默认情况下， <strong><code>CategoricalArrays.jl</code> 将会使用 32 位 无符号整数 <code>UInt32</code> 来表示基础的类别</strong>：</p>
<pre class="language-julia"><code>typeof(categorical([&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]))</code></pre>
<pre class="language-plain"><code>CategoricalVector{String, UInt32, String, CategoricalValue{String, UInt32}, Union{}}</code></pre>
<p>这意味着，<code>CategoricalArrays.jl</code> 将最多可以在一列中表示 <span class="math inline">\(2^{32}\)</span> 中不同的类别，这是一个非常大的数字 (接近 43亿)。 在处理常规数据时，可能永远都不需要如此级别的容量<a href="/JuliaDataScience#fn17" class="footnote-ref" id="fnref17" role="doc-noteref"><sup>17</sup></a>。 这就是为什么 <code>categorical</code> 有一个 <code>compress</code> 参数， 它可以通过接收 <code>true</code> 或 <code>false</code> 来决定是否压缩基本分类数据。 如果传入了 <strong><code>compress=true</code>, <code>CategoricalArrays.jl</code> 将会尝试把基本分类数据压缩到最小的 <code>UInt</code> 表示</strong>。 例如，之前的 <code>categorical</code> 向量可以表示为 8 位无符号整数 <code>UInt8</code> (通常这样做，因为这是 Julia 中最小的无符号整型)：</p>
<pre class="language-julia"><code>typeof(categorical([&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]; compress=true))</code></pre>
<pre class="language-plain"><code>CategoricalVector{String, UInt8, String, CategoricalValue{String, UInt8}, Union{}}</code></pre>
<p>这些都意味着什么呢？ 假设你有一个超级大的向量。 例如，1 百万元素的向量，但仅有四种基本类型：A，B，C，或 D。 如果不想压缩生成的分类向量，那么你将会存储 1 百万 <code>UInt32</code> 类型的元素。 另一方面，如果压缩它，那么将会存储 1 百万 <code>UInt8</code> 类型的元素。 可以使用 <code>Base.summarysize</code> 函数获得给定对象的基本大小（以字节为单位）。 因此，让我们量化一下，在不压缩一百万分类向量时，将需要多少更多的内存：</p>
<pre class="julia"><code>using Random</code></pre>
<pre class="language-julia"><code>one_mi_vec = rand([&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;], 1_000_000)
Base.summarysize(categorical(one_mi_vec))</code></pre>
<pre class="language-plain"><code>4000612</code></pre>
<p>4 百万字节，大概是 3.8 MB。 不要觉得我们错了，这是对原始字符串向量的很大改进：</p>
<pre class="language-julia"><code>Base.summarysize(one_mi_vec)</code></pre>
<pre class="language-plain"><code>8000076</code></pre>
<p>通过使用 <code>CategoricalArrays.jl</code> 将数据表示为 <code>UInt32</code> ，我们节省了 50% 的原始数据大小。</p>
<p>现在与压缩选项进行对比：</p>
<pre class="language-julia"><code>Base.summarysize(categorical(one_mi_vec; compress=true))</code></pre>
<pre class="language-plain"><code>1000564</code></pre>
<p>在不丢失信息的情况下，我们将大小减少到原始未压缩向量大小的25% （四分之一）。 我们的压缩分类向量现在有100万字节，大约是1.0 MB。</p>
<p>因此，只要有提高性能的可能，请考虑在分类数据中使用 <code>compress=true</code>。</p>


<div class="bottom-nav">
    <p id="nav-prev" style="text-align: left;">
        <a class="menu-level-2" href="/JuliaDataScience/groupby_combine"><b>4.8</b> Groupby 和 Combine</a> <kbd>←</kbd>
        <span id="nav-next" style="float: right;">
            <kbd>→</kbd> <a class="menu-level-1" href="/JuliaDataScience/DataVisualizationMakie"><b>5</b> 使用 Makie.jl 做数据可视化</a>
        </span>
    </p>
</div>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn17" role="doc-endnote"><p> 17. 同时注意到常规数据 （最多 10 000 行）不算大数据（超过 100 000 行）。因此，若是主要处理大数据，请你谨慎设定分类值。<a href="/JuliaDataScience#fnref17" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>


<div class="license">
    <br/>
  <br/>
  <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a>
    Jose Storopoli, Rik Huijzer, Lazaro Alonso, 刘贵欣 (中文翻译), 田俊 （中文审校）
</div>
</div>
</div>
</body>
</html>