<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US" xml:lang="en-US">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Jose Storopoli" />
  <meta name="author" content="Rik Huijzer" />
  <meta name="author" content="Lazaro Alonso" />
  <meta name="author" content="刘贵欣 (中文翻译)" />
  <meta name="author" content="田俊 （中文审校）" />
  <title>布局 - Julia Data Science</title>
  <link rel="shortcut icon" type="image/png" href="/JuliaDataScience/favicon.png"/>
  <link rel="stylesheet" href="/JuliaDataScience/style.css"/>
    <script src="/JuliaDataScience/mousetrap.min.js"></script>
    <style>
  @font-face {
    font-family: JuliaMono-Regular;
    src: url("/JuliaDataScience/JuliaMono-Regular.woff2");
  }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>
  <link rel="stylesheet" href="/JuliaDataScience/github.min.css">
<script src="/JuliaDataScience/highlight.min.js"></script>
<script src="/JuliaDataScience/julia.min.js"></script>
<script>
document.addEventListener('DOMContentLoaded', (event) => {
    document.querySelectorAll('pre').forEach((el) => {
        hljs.highlightElement(el);
    });
});
</script>
 
</head>
<body>
<script>
function click_next() {
  var next = document.getElementById('nav-next');
  next.firstElementChild.nextElementSibling.click();
}
function click_prev() {
  var prev = document.getElementById('nav-prev');
  prev.firstElementChild.click();
}
Mousetrap.bind('right', click_next);
Mousetrap.bind('h', click_prev);
Mousetrap.bind('left', click_prev);
Mousetrap.bind('l', click_next);
</script>

<div class="books-container">
<aside class="books-menu">
<input type="checkbox" id="menu">
<label for="menu">☰</label>
<div class="books-title">
<a href="/JuliaDataScience/">Julia Data Science</a>
</div><br />
<span class="books-subtitle">

</span>
<div class="books-menu-content">
<li><a class="menu-level-1" href="/JuliaDataScience/preface"><b>1</b> 前言</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/why_data_science"><b>1.1</b> 什么是数据科学？</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/engineering"><b>1.2</b> 软件工程</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/acknowledgements"><b>1.3</b> 致谢</a></li>
<li><a class="menu-level-1" href="/JuliaDataScience/why_julia"><b>2</b> 为什么选择 Julia ?</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/non-programmers"><b>2.1</b> 从未编过程</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/programmers"><b>2.2</b> 有编程经验</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/julia_accomplish"><b>2.3</b> Julia 想实现什么?</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/julia_wild"><b>2.4</b> Julia 应用案例</a></li>
<li><a class="menu-level-1" href="/JuliaDataScience/julia_basics"><b>3</b> Julia 基础</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/ide"><b>3.1</b> 开发环境</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/syntax"><b>3.2</b> 语法</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/data_structures"><b>3.3</b> 原生数据结构</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/filesystem"><b>3.4</b> 文件系统</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/standardlibrary"><b>3.5</b> Julia 标准库</a></li>
<li><a class="menu-level-1" href="/JuliaDataScience/dataframes"><b>4</b> DataFrames.jl</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/load_save"><b>4.1</b> 加载和保存文件</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/index_summarize"><b>4.2</b> Index 和 Summarize</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/filter_subset"><b>4.3</b> Filter 和 Subset</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/select"><b>4.4</b> Select</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/missing_data"><b>4.5</b> 类型和缺失值</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/join"><b>4.6</b> Join</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/df_transform"><b>4.7</b> 变量变换</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/groupby_combine"><b>4.8</b> Groupby 和 Combine</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/df_performance"><b>4.9</b> 性能</a></li>
<li><a class="menu-level-1" href="/JuliaDataScience/DataVisualizationMakie"><b>5</b> 使用 Makie.jl 做数据可视化</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/cairomakie"><b>5.1</b> CairoMakie.jl</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/datavisMakie_attributes"><b>5.2</b> 属性</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/themes"><b>5.3</b> 主题</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/using_latex"><b>5.4</b> 使用 LaTeXStrings.jl</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/makie_colors"><b>5.5</b> 颜色和颜色图（Colormap）</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/makie_layouts"><b>5.6</b> 布局</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/glmakie"><b>5.7</b> GLMakie.jl</a></li>
<li><a class="menu-level-1" href="/JuliaDataScience/appendix"><b>6</b> 附录</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/appendix_pkg"><b>6.1</b> 库的版本</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/notation"><b>6.2</b> 符号</a></li>
<li><a class="menu-level-1" href="/JuliaDataScience/references"><b></b> 参考文献</a></li>
</div>
</aside>

<div class="books-content">
<h2 data-number="5.6" id="sec:makie_layouts"><span class="header-section-number">5.6</span> 布局</h2>
<p>一个完整的 <strong>画布/布局</strong> 是由 <code>Figure</code> 定义的，创建后将在其中填充各种内容。 下面将以一个包含 <code>Axis</code>，<code>Legend</code> 和 <code>Colorbar</code> 的简单例子开始。 在这项任务中， 就像 <code>Array</code>/<code>Matrix</code> 那样，可以使用 <code>rows</code> 和 <code>columns</code> 索引 <code>Figure</code>。 <code>Axis</code> 位于 <strong>第 1 行，第 1 列</strong>， 即为 <code>fig[1, 1]</code>。 <code>Colorbar</code> 位于 <strong>第 1 行，第 2 列</strong>， 即为 <code>fig[1, 2]</code>。 另外， <code>Legend</code> 位于 <strong>第 2 行</strong> 和 <strong>第 1 - 2 列</strong>， 即为 <code>fig[2, 1:2]</code>。</p>
<pre class="language-julia"><code>function first_layout()
    seed!(123)
    x, y, z = randn(6), randn(6), randn(6)
    fig = Figure(resolution=(600, 400), backgroundcolor=:grey90)
    ax = Axis(fig[1, 1], backgroundcolor=:white)
    pltobj = scatter!(ax, x, y; color=z, label=&quot;scatters&quot;)
    lines!(ax, x, 1.1y; label=&quot;line&quot;)
    Legend(fig[2, 1:2], ax, &quot;labels&quot;, orientation=:horizontal)
    Colorbar(fig[1, 2], pltobj, label=&quot;colorbar&quot;)
    fig
end
first_layout()</code></pre>
<figure>
<img src="/JuliaDataScience/im/JDS_first_layout_.svg" id="fig:first_layout" style="width:60.0%" alt="Figure 27: First Layout." /><figcaption aria-hidden="true">Figure 27: First Layout.</figcaption>
</figure>
<p>这看起来已经不错了，但能变得更好。可以使用以下关键字和方法来解决图的间距问题：</p>
<ul>
<li><code>figure_padding=(left, right, bottom, top)</code></li>
<li><code>padding=(left, right, bottom, top)</code></li>
</ul>
<p>改变 <code>Legend</code> 或 <code>Colorbar</code> 实际大小的方法为：</p>
<blockquote>
<ul>
<li><code>tellheight=true</code> or <code>false</code></li>
<li><code>tellwidth=true</code> or <code>false</code></li>
</ul>
<p><strong>将这些设置为 <code>true</code> 后则需考虑 <code>Legend</code> 或 <code>Colorbar</code> 的实际大小（高或宽）。</strong> 然后这些内容将会相应地调整大小。</p>
</blockquote>
<p>可以使用以下方法指定行和列的间距：</p>
<blockquote>
<ul>
<li><code>colgap!(fig.layout, col, separation)</code></li>
<li><code>rowgap!(fig.layout, row, separation)</code></li>
</ul>
<p><strong>列间距</strong> （<code>colgap!</code>），如果给定了 <code>col</code>，那么间距将只应用在指定的列。 <strong>行间距</strong> （<code>rowgap!</code>），如果给定了 <code>row</code>，那么间距将只应用在指定的行。</p>
</blockquote>
<p>接下来将学习如何将内容放进 <strong>突出部分（protrusion）</strong>，即为 <strong>标题 <code>x</code> 和 <code>y</code>，或 <code>ticks</code> 以及 <code>label</code></strong> 保留的空间。 实现方法是将位置索引改为 <code>fig[i, j, protrusion]</code>， 其中 <em><code>protrusion</code></em> 可以是 <code>Left()</code>， <code>Right()</code>，<code>Bottom()</code> 和 <code>Top()</code>，或者是四个角 <code>TopLeft()</code>， <code>TopRight()</code>， <code>BottomRight()</code>，<code>BottomLeft()</code>。 这些选项将在如下的例子中使用：</p>
<pre class="language-julia"><code>function first_layout_fixed()
    seed!(123)
    x, y, z = randn(6), randn(6), randn(6)
    fig = Figure(figure_padding=(0, 3, 5, 2), resolution=(600, 400),
        backgroundcolor=:grey90, font=&quot;CMU Serif&quot;)
    ax = Axis(fig[1, 1], xlabel=L&quot;x&quot;, ylabel=L&quot;y&quot;,
        title=&quot;Layout example&quot;, backgroundcolor=:white)
    pltobj = scatter!(ax, x, y; color=z, label=&quot;scatters&quot;)
    lines!(ax, x, 1.1y, label=&quot;line&quot;)
    Legend(fig[2, 1:2], ax, &quot;Labels&quot;, orientation=:horizontal,
        tellheight=true, titleposition=:left)
    Colorbar(fig[1, 2], pltobj, label=&quot;colorbar&quot;)
    # additional aesthetics
    Box(fig[1, 1, Right()], color=(:slateblue1, 0.35))
    Label(fig[1, 1, Right()], &quot;protrusion&quot;, textsize=18,
        rotation=pi / 2, padding=(3, 3, 3, 3))
    Label(fig[1, 1, TopLeft()], &quot;(a)&quot;, textsize=18, padding=(0, 3, 8, 0))
    colgap!(fig.layout, 5)
    rowgap!(fig.layout, 5)
    fig
end
first_layout_fixed()</code></pre>
<figure>
<img src="/JuliaDataScience/im/JDS_first_layout_fixed_.svg" id="fig:first_layout_fixed" style="width:60.0%" alt="Figure 28: First Layout Fixed." /><figcaption aria-hidden="true">Figure 28: First Layout Fixed.</figcaption>
</figure>
<p>这里在 <code>TopLeft()</code>添加标签 <code>(a)</code> 可能是不必要的， 因为标签仅在有两个以上的图时有意义。 在接下来的例子中，我们将继续使用之前的工具和一些新工具，并创建一个更丰富、更复杂的图。</p>
<p>可以使用以下函数隐藏图的装饰部分和轴线：</p>
<blockquote>
<ul>
<li><code>hidedecorations!(ax; kwargs...)</code></li>
<li><code>hidexdecorations!(ax; kwargs...)</code></li>
<li><code>hideydecorations!(ax; kwargs...)</code></li>
<li><code>hidespines!(ax; kwargs...)</code></li>
</ul>
</blockquote>
<p>应记住总是可以调用 <code>help</code> 查看能够传递的参数，例如：</p>
<pre class="language-julia"><code>help(hidespines!)</code></pre>
<pre class="output"><code>  hidespines!(la::Axis, spines::Symbol... = (:l, :r, :b, :t)...)

  Hide all specified axis spines. Hides all spines by default, otherwise
  choose with the symbols :l, :r, :b and :t.

  hidespines! has the following function signatures:

    (Vector, Vector)
    (Vector, Vector, Vector)
    (Matrix)

  Available attributes for Combined{Makie.MakieLayout.hidespines!} are:

  </code></pre>
<p>另外，对于 <code>hidedecorations!</code> 有：</p>
<pre class="language-julia"><code>help(hidedecorations!)</code></pre>
<pre class="output"><code>  hidedecorations!(la::Axis)

  Hide decorations of both x and y-axis: label, ticklabels, ticks and grid.

  hidedecorations! has the following function signatures:

    (Vector, Vector)
    (Vector, Vector, Vector)
    (Matrix)

  Available attributes for Combined{Makie.MakieLayout.hidedecorations!} are:

  </code></pre>
<p>对于 <strong>不想隐藏的</strong> 元素，仅需要将它们的值设置为 <code>false</code>，即 <code>hideydecorations!(ax; ticks=false, grid=false)</code>。</p>
<p>同步 <code>Axis</code> 的方式如下：</p>
<blockquote>
<ul>
<li><code>linkaxes!</code>， <code>linkyaxes!</code> 和 <code>linkxaxes!</code></li>
</ul>
<p>这在需要共享轴时会变得很有用。 另一种获得共享轴的方法是设置 <code>limits!</code>。</p>
</blockquote>
<p>使用以下方式可一次性设定<code>limits</code>，当然也能单独为每个方向的轴单独设定：</p>
<blockquote>
<ul>
<li><code>limits!(ax; l, r, b, t)</code>，其中 <code>l</code> 为左侧, <code>r</code> 右侧，<code>b</code> 底部， 和 <code>t</code> 顶部。</li>
</ul>
<p>还能使用 <code>ylims!(low, high)</code> 或 <code>xlims!(low, high)</code>，甚至可以通过 <code>ylims!(low=0)</code> 或 <code>xlims!(high=1)</code> 只设定一边。</p>
</blockquote>
<p>例子如下：</p>
<pre class="language-julia"><code>function complex_layout_double_axis()
    seed!(123)
    x = LinRange(0, 1, 10)
    y = LinRange(0, 1, 10)
    z = rand(10, 10)
    fig = Figure(resolution=(600, 400), font=&quot;CMU Serif&quot;, backgroundcolor=:grey90)
    ax1 = Axis(fig, xlabel=L&quot;x&quot;, ylabel=L&quot;y&quot;)
    ax2 = Axis(fig, xlabel=L&quot;x&quot;)
    heatmap!(ax1, x, y, z; colorrange=(0, 1))
    series!(ax2, abs.(z[1:4, :]); labels=[&quot;lab $i&quot; for i = 1:4], color=:Set1_4)
    hm = scatter!(10x, y; color=z[1, :], label=&quot;dots&quot;, colorrange=(0, 1))
    hideydecorations!(ax2, ticks=false, grid=false)
    linkyaxes!(ax1, ax2)
    #layout
    fig[1, 1] = ax1
    fig[1, 2] = ax2
    Label(fig[1, 1, TopLeft()], &quot;(a)&quot;, textsize=18, padding=(0, 6, 8, 0))
    Label(fig[1, 2, TopLeft()], &quot;(b)&quot;, textsize=18, padding=(0, 6, 8, 0))
    Colorbar(fig[2, 1:2], hm, label=&quot;colorbar&quot;, vertical=false, flipaxis=false)
    Legend(fig[1, 3], ax2, &quot;Legend&quot;)
    colgap!(fig.layout, 5)
    rowgap!(fig.layout, 5)
    fig
end
complex_layout_double_axis()</code></pre>
<figure>
<img src="/JuliaDataScience/im/JDS_complex_layout_double_axis_.svg" id="fig:complex_layout_double_axis" style="width:60.0%" alt="Figure 29: Complex layout double axis." /><figcaption aria-hidden="true">Figure 29: Complex layout double axis.</figcaption>
</figure>
<p>如上所示， <code>Colorbar</code> 的方向已经变为水平且它的标签也处在其下方。 这是因为设定了 <code>vertical=false</code> 和 <code>flipaxis=false</code>。 另外，也可以将更多的 <code>Axis</code> 添加到 <code>fig</code> 里，甚至可以是 <code>Colorbar</code> 和 <code>Legend</code>，然后再构建布局。</p>
<p>另一种常见布局是热力图组成的正方网格：</p>
<pre class="language-julia"><code>function squares_layout()
    seed!(123)
    letters = reshape(collect(&#39;a&#39;:&#39;d&#39;), (2, 2))
    fig = Figure(resolution=(600, 400), fontsize=14, font=&quot;CMU Serif&quot;,
        backgroundcolor=:grey90)
    axs = [Axis(fig[i, j], aspect=DataAspect()) for i = 1:2, j = 1:2]
    hms = [heatmap!(axs[i, j], randn(10, 10), colorrange=(-2, 2))
           for i = 1:2, j = 1:2]
    Colorbar(fig[1:2, 3], hms[1], label=&quot;colorbar&quot;)
    [Label(fig[i, j, TopLeft()], &quot;($(letters[i, j]))&quot;, textsize=16,
        padding=(-2, 0, -20, 0)) for i = 1:2, j = 1:2]
    colgap!(fig.layout, 5)
    rowgap!(fig.layout, 5)
    fig
end
squares_layout()</code></pre>
<figure>
<img src="/JuliaDataScience/im/JDS_squares_layout_.svg" id="fig:squares_layout" style="width:60.0%" alt="Figure 30: Squares layout." /><figcaption aria-hidden="true">Figure 30: Squares layout.</figcaption>
</figure>
<p>上图中每一个标签都位于 <strong>突出部分</strong> 并且每一个 <code>Axis</code> 都有 <code>AspectData()</code> 率属性。 图中 <code>Colorbar</code> 位于第三列，并从第一行跨到第二行。</p>
<p>下例将使用称为 <code>Mixed()</code> 的<strong>对齐模式</strong>，这在处理 <code>Axis</code> 间的大量空白区域时很有用，而这些空白区域通常是由长标签导致的。 另外，本例还需要使用 Julia 标准库中的 <code>Dates</code> 。</p>
<pre><code>using Dates</code></pre>
<pre class="language-julia"><code>function mixed_mode_layout()
    seed!(123)
    longlabels = [&quot;$(today() - Day(1))&quot;, &quot;$(today())&quot;, &quot;$(today() + Day(1))&quot;]
    fig = Figure(resolution=(600, 400), fontsize=12,
        backgroundcolor=:grey90, font=&quot;CMU Serif&quot;)
    ax1 = Axis(fig[1, 1])
    ax2 = Axis(fig[1, 2], xticklabelrotation=pi / 2, alignmode=Mixed(bottom=0),
        xticks=([1, 5, 10], longlabels))
    ax3 = Axis(fig[2, 1:2])
    ax4 = Axis(fig[3, 1:2])
    axs = [ax1, ax2, ax3, ax4]
    [lines!(ax, 1:10, rand(10)) for ax in axs]
    hidexdecorations!(ax3; ticks=false, grid=false)
    Box(fig[2:3, 1:2, Right()], color=(:slateblue1, 0.35))
    Label(fig[2:3, 1:2, Right()], &quot;protrusion&quot;, rotation=pi / 2, textsize=14,
        padding=(3, 3, 3, 3))
    Label(fig[1, 1:2, Top()], &quot;Mixed alignmode&quot;, textsize=16,
        padding=(0, 0, 15, 0))
    colsize!(fig.layout, 1, Auto(2))
    rowsize!(fig.layout, 2, Auto(0.5))
    rowsize!(fig.layout, 3, Auto(0.5))
    rowgap!(fig.layout, 1, 15)
    rowgap!(fig.layout, 2, 0)
    colgap!(fig.layout, 5)
    fig
end
mixed_mode_layout()</code></pre>
<figure>
<img src="/JuliaDataScience/im/JDS_mixed_mode_layout_.svg" id="fig:mixed_mode_layout" style="width:60.0%" alt="Figure 31: Mixed mode layout." /><figcaption aria-hidden="true">Figure 31: Mixed mode layout.</figcaption>
</figure>
<p>如上，参数 <code>alignmode=Mixed(bottom=0)</code> 将边界框移动到底部，使其与左侧面板保持对齐。</p>
<p>从上图也可以看到 <code>colsize!</code> 和 <code>rowsize!</code> 如何作用于不同的行和列。 可以向函数传递一个数字而不是 <code>Auto()</code>，但那会固定所有的设置。 另外， 在定义 <code>Axis</code> 时也可以设定 <code>height</code> 或 <code>width</code>，例如 <code>Axis(fig, heigth=50)</code> 将会固定轴的高度。</p>
<h3 data-number="5.6.1" id="嵌套-axis-subplots"><span class="header-section-number">5.6.1</span> 嵌套 <code>Axis</code> (<em>subplots</em>)</h3>
<p>精准定义一组 <code>Axis</code> (<em>subplots</em>) 也是可行的， 可以使用一组 <code>Axis</code> 构造具有多行多列的图。 例如，下面展示了一组较复杂的 <code>Axis</code>：</p>
<pre class="language-julia"><code>function nested_sub_plot!(fig)
    color = rand(RGBf)
    ax1 = Axis(fig[1, 1], backgroundcolor=(color, 0.25))
    ax2 = Axis(fig[1, 2], backgroundcolor=(color, 0.25))
    ax3 = Axis(fig[2, 1:2], backgroundcolor=(color, 0.25))
    ax4 = Axis(fig[1:2, 3], backgroundcolor=(color, 0.25))
    return (ax1, ax2, ax3, ax4)
end</code></pre>
<p>当通过多次调用它来构建更复杂的图时，可以得到：</p>
<pre class="language-julia"><code>function main_figure()
    fig = Figure()
    Axis(fig[1, 1])
    nested_sub_plot!(fig[1, 2])
    nested_sub_plot!(fig[1, 3])
    nested_sub_plot!(fig[2, 1:3])
    fig
end
main_figure()</code></pre>
<figure>
<img src="/JuliaDataScience/im/JDS_main_figure_.svg" id="fig:main_figure" style="width:60.0%" alt="Figure 32: Main figure." /><figcaption aria-hidden="true">Figure 32: Main figure.</figcaption>
</figure>
<p>注意，这里可以调用不同的子图函数。 另外，每一个 <code>Axis</code> 都是 <code>Figure</code> 的独立部分。 因此，当在进行 <code>rowgap!</code>或者 <code>colsize!</code> 这样的操作时，你需要考虑是对每一个子图单独作用还是对所有的图一起作用。</p>
<p>对于组合的 <code>Axis</code> (<em>subplots</em>) 可以使用 <code>GridLayout()</code>， 它能用来构造更复杂的 <code>Figure</code>。</p>
<h3 data-number="5.6.2" id="嵌套网格布局"><span class="header-section-number">5.6.2</span> 嵌套网格布局</h3>
<p>可以使用 <code>GridLayout()</code> 组合子图，这种方法能够更自由地构建更复杂的图。 这里再次使用之前的 <code>nested_sub_plot!</code>，它定义了三组子图和一个普通的 <code>Axis</code>：</p>
<pre class="language-julia"><code>function nested_Grid_Layouts()
    fig = Figure(backgroundcolor=RGBf(0.96, 0.96, 0.96))
    ga = fig[1, 1] = GridLayout()
    gb = fig[1, 2] = GridLayout()
    gc = fig[1, 3] = GridLayout()
    gd = fig[2, 1:3] = GridLayout()
    gA = Axis(ga[1, 1])
    nested_sub_plot!(gb)
    axsc = nested_sub_plot!(gc)
    nested_sub_plot!(gd)
    [hidedecorations!(axsc[i], grid=false, ticks=false) for i = 1:length(axsc)]
    colgap!(gc, 5)
    rowgap!(gc, 5)
    rowsize!(fig.layout, 2, Auto(0.5))
    colsize!(fig.layout, 1, Auto(0.5))
    fig
end
nested_Grid_Layouts()</code></pre>
<figure>
<img src="/JuliaDataScience/im/JDS_nested_Grid_Layouts_.svg" id="fig:nested_Grid_Layouts" style="width:60.0%" alt="Figure 33: Nested Grid Layouts." /><figcaption aria-hidden="true">Figure 33: Nested Grid Layouts.</figcaption>
</figure>
<p>现在，对每一组使用 <code>rowgap!</code> 或 <code>colsize!</code> 将是可行的，并且 <code>rowsize!, colsize!</code> 也能够应用于 <code>GridLayout()</code>。</p>
<h3 data-number="5.6.3" id="插图"><span class="header-section-number">5.6.3</span> 插图</h3>
<p>目前，绘制 <code>inset</code> 是一项棘手的工作。 本节展示两种在初始时通过定义辅助函数实现绘制插图的方法。 第一种是定义 <code>BBox</code>，它存在于整个 <code>Figure</code> 空间：</p>
<pre class="language-julia"><code>function add_box_inset(fig; left=100, right=250, bottom=200, top=300,
    bgcolor=:grey90)
    inset_box = Axis(fig, bbox=BBox(left, right, bottom, top),
        xticklabelsize=12, yticklabelsize=12, backgroundcolor=bgcolor)
    # bring content upfront
    translate!(inset_box.scene, 0, 0, 10)
    elements = keys(inset_box.elements)
    filtered = filter(ele -&gt; ele != :xaxis &amp;&amp; ele != :yaxis, elements)
    foreach(ele -&gt; translate!(inset_box.elements[ele], 0, 0, 9), filtered)
    return inset_box
end</code></pre>
<p>然后可以按照如下方式轻松地绘制插图：</p>
<pre class="language-julia"><code>function figure_box_inset()
    fig = Figure(resolution=(600, 400))
    ax = Axis(fig[1, 1], backgroundcolor=:white)
    inset_ax1 = add_box_inset(fig; left=100, right=250, bottom=200, top=300,
        bgcolor=:grey90)
    inset_ax2 = add_box_inset(fig; left=500, right=600, bottom=100, top=200,
        bgcolor=(:white, 0.65))
    lines!(ax, 1:10)
    lines!(inset_ax1, 1:10)
    scatter!(inset_ax2, 1:10, color=:black)
    fig
end
figure_box_inset()</code></pre>
<figure>
<img src="/JuliaDataScience/im/JDS_figure_box_inset_.svg" id="fig:figure_box_inset" style="width:60.0%" alt="Figure 34: Figure box inset." /><figcaption aria-hidden="true">Figure 34: Figure box inset.</figcaption>
</figure>
<p>其中 <code>Box</code> 的尺寸受到 <code>Figure</code>中 <code>resolution</code> 参数的约束。 注意，也可以在 <code>Axis</code> 外绘制插图。 另一种绘制插图的方法是，在位置<code>fig[i, j]</code>处定义一个新的 <code>Axis</code>，并且指定 <code>width</code>， <code>height</code>， <code>halign</code> 和 <code>valign</code>。 如下面的函数例子所示：</p>
<pre class="language-julia"><code>function add_axis_inset(; pos=fig[1, 1], halign=0.1, valign=0.5,
    width=Relative(0.5), height=Relative(0.35), bgcolor=:lightgray)
    inset_box = Axis(pos, width=width, height=height,
        halign=halign, valign=valign, xticklabelsize=12, yticklabelsize=12,
        backgroundcolor=bgcolor)
    # bring content upfront
    translate!(inset_box.scene, 0, 0, 10)
    elements = keys(inset_box.elements)
    filtered = filter(ele -&gt; ele != :xaxis &amp;&amp; ele != :yaxis, elements)
    foreach(ele -&gt; translate!(inset_box.elements[ele], 0, 0, 9), filtered)
    return inset_box
end</code></pre>
<p>在下面的例子中，如果总图的大小发生变化，那么将重新缩放灰色背景的 <code>Axis</code>。 同时 <strong>插图</strong> 要受到 <code>Axis</code> 位置的约束。</p>
<pre class="language-julia"><code>function figure_axis_inset()
    fig = Figure(resolution=(600, 400))
    ax = Axis(fig[1, 1], backgroundcolor=:white)
    inset_ax1 = add_axis_inset(; pos=fig[1, 1], halign=0.1, valign=0.65,
        width=Relative(0.3), height=Relative(0.3), bgcolor=:grey90)
    inset_ax2 = add_axis_inset(; pos=fig[1, 1], halign=1, valign=0.25,
        width=Relative(0.25), height=Relative(0.3), bgcolor=(:white, 0.65))
    lines!(ax, 1:10)
    lines!(inset_ax1, 1:10)
    scatter!(inset_ax2, 1:10, color=:black)
    fig
end
figure_axis_inset()</code></pre>
<figure>
<img src="/JuliaDataScience/im/JDS_figure_axis_inset_.svg" id="fig:figure_axis_inset" style="width:60.0%" alt="Figure 35: Figure axis inset." /><figcaption aria-hidden="true">Figure 35: Figure axis inset.</figcaption>
</figure>
<p>以上包含了 Makie 中布局选项的大多数常见用例。 现在，让我们接下来使用 <code>GLMakie.jl</code> 绘制一些漂亮的3D示例图。</p>


<div class="bottom-nav">
    <p id="nav-prev" style="text-align: left;">
        <a class="menu-level-2" href="/JuliaDataScience/makie_colors"><b>5.5</b> 颜色和颜色图（Colormap）</a> <kbd>←</kbd>
        <span id="nav-next" style="float: right;">
            <kbd>→</kbd> <a class="menu-level-2" href="/JuliaDataScience/glmakie"><b>5.7</b> GLMakie.jl</a>
        </span>
    </p>
</div>


<div class="license">
    <br/>
  <br/>
  <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a>
    Jose Storopoli, Rik Huijzer, Lazaro Alonso, 刘贵欣 (中文翻译), 田俊 （中文审校）
</div>
</div>
</div>
</body>
</html>