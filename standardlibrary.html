<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US" xml:lang="en-US">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Jose Storopoli" />
  <meta name="author" content="Rik Huijzer" />
  <meta name="author" content="Lazaro Alonso" />
  <meta name="author" content="刘贵欣 (中文翻译)" />
  <meta name="author" content="田俊 （中文审校）" />
  <title>Julia 标准库 - Julia Data Science</title>
  <link rel="shortcut icon" type="image/png" href="/JuliaDataScience/favicon.png"/>
  <link rel="stylesheet" href="/JuliaDataScience/style.css"/>
    <script src="/JuliaDataScience/mousetrap.min.js"></script>
    <style>
  @font-face {
    font-family: JuliaMono-Regular;
    src: url("/JuliaDataScience/JuliaMono-Regular.woff2");
  }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>
  <link rel="stylesheet" href="/JuliaDataScience/github.min.css">
<script src="/JuliaDataScience/highlight.min.js"></script>
<script src="/JuliaDataScience/julia.min.js"></script>
<script>
document.addEventListener('DOMContentLoaded', (event) => {
    document.querySelectorAll('pre').forEach((el) => {
        hljs.highlightElement(el);
    });
});
</script>
 
</head>
<body>
<script>
function click_next() {
  var next = document.getElementById('nav-next');
  next.firstElementChild.nextElementSibling.click();
}
function click_prev() {
  var prev = document.getElementById('nav-prev');
  prev.firstElementChild.click();
}
Mousetrap.bind('right', click_next);
Mousetrap.bind('h', click_prev);
Mousetrap.bind('left', click_prev);
Mousetrap.bind('l', click_next);
</script>

<div class="books-container">
<aside class="books-menu">
<input type="checkbox" id="menu">
<label for="menu">☰</label>
<div class="books-title">
<a href="/JuliaDataScience/">Julia Data Science</a>
</div><br />
<span class="books-subtitle">

</span>
<div class="books-menu-content">
<li><a class="menu-level-1" href="/JuliaDataScience/preface"><b>1</b> 前言</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/why_data_science"><b>1.1</b> 什么是数据科学？</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/engineering"><b>1.2</b> 软件工程</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/acknowledgements"><b>1.3</b> 致谢</a></li>
<li><a class="menu-level-1" href="/JuliaDataScience/why_julia"><b>2</b> 为什么选择 Julia ?</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/non-programmers"><b>2.1</b> 从未编过程</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/programmers"><b>2.2</b> 有编程经验</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/julia_accomplish"><b>2.3</b> Julia 想实现什么?</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/julia_wild"><b>2.4</b> Julia 应用案例</a></li>
<li><a class="menu-level-1" href="/JuliaDataScience/julia_basics"><b>3</b> Julia 基础</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/ide"><b>3.1</b> 开发环境</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/syntax"><b>3.2</b> 语法</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/data_structures"><b>3.3</b> 原生数据结构</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/filesystem"><b>3.4</b> 文件系统</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/standardlibrary"><b>3.5</b> Julia 标准库</a></li>
<li><a class="menu-level-1" href="/JuliaDataScience/dataframes"><b>4</b> DataFrames.jl</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/load_save"><b>4.1</b> 加载和保存文件</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/index_summarize"><b>4.2</b> Index 和 Summarize</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/filter_subset"><b>4.3</b> Filter 和 Subset</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/select"><b>4.4</b> Select</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/missing_data"><b>4.5</b> 类型和缺失值</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/join"><b>4.6</b> Join</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/df_transform"><b>4.7</b> 变量变换</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/groupby_combine"><b>4.8</b> Groupby 和 Combine</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/df_performance"><b>4.9</b> 性能</a></li>
<li><a class="menu-level-1" href="/JuliaDataScience/DataVisualizationMakie"><b>5</b> 使用 Makie.jl 做数据可视化</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/cairomakie"><b>5.1</b> CairoMakie.jl</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/datavisMakie_attributes"><b>5.2</b> 属性</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/themes"><b>5.3</b> 主题</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/using_latex"><b>5.4</b> 使用 LaTeXStrings.jl</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/makie_colors"><b>5.5</b> 颜色和颜色图（Colormap）</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/makie_layouts"><b>5.6</b> 布局</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/glmakie"><b>5.7</b> GLMakie.jl</a></li>
<li><a class="menu-level-1" href="/JuliaDataScience/appendix"><b>6</b> 附录</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/appendix_pkg"><b>6.1</b> 库的版本</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/notation"><b>6.2</b> 符号</a></li>
<li><a class="menu-level-1" href="/JuliaDataScience/references"><b></b> 参考文献</a></li>
</div>
</aside>

<div class="books-content">
<h2 data-number="3.5" id="sec:standardlibrary"><span class="header-section-number">3.5</span> Julia 标准库</h2>
<p>Julia 拥有 <strong>丰富的标准库</strong>，每个 Julia 发行版都可以使用这些库。 与截至目前提到的一切相反，例如类型，数据结构和文件系统；在使用特定的模块或函数前， <strong>需要将标准库模块导入到环境中</strong>。</p>
<p>这可以通过 <code>using</code> 或 <code>import</code>实现。 本书将使用 <code>using</code> 导入代码：</p>
<pre class="julia"><code>using ModuleName</code></pre>
<p>在执行上述操作后，就可以使用 <code>ModuleName</code> 中所有的函数和类型。</p>
<h3 data-number="3.5.1" id="sec:dates"><span class="header-section-number">3.5.1</span> 日期</h3>
<p>了解如何处理日期和时间戳在数据科学中很重要。 正如在 <strong>为什么选择 Julia?</strong> (Section <a href="/JuliaDataScience/why_julia#sec:why_julia">2</a>) 节讨论的那样，Python 中的 <code>pandas</code> 使用它自己的 <code>datetime</code> 类型处理日期。 R 语言中 TidyVerse 的 <code>lubridate</code> 包中也是如此，它也定义了自己的 <code>datetime</code> 类型来处理日期。 在 Julia 软件包中，不需要编写自己的日期逻辑，因为 Julia 标准库中有一个名为 <code>Dates</code> 的日期处理模块。</p>
<p>首先加载 <code>Dates</code> 模块到工作空间中：</p>
<pre class="julia"><code>using Dates</code></pre>
<h4 data-number="3.5.1.1" id="sec:dates_types"><span class="header-section-number">3.5.1.1</span> <code>Date</code> and <code>DateTime</code> Types</h4>
<p><code>Dates</code> 标准库模块有 <strong>两种处理日期的类型</strong>:</p>
<ol type="1">
<li><code>Date</code>: 表示以天为单位的时间和</li>
<li><code>DateTime</code>: 表示以毫秒为单位的时间。</li>
</ol>
<p>构造 <code>Date</code> 和 <code>DateTime</code> 的方法是，向默认构造器传递表示年，月，日，小时等等的整数：</p>
<pre class="language-julia"><code>Date(1987) # year</code></pre>
<pre class="output"><code>1987-01-01</code></pre>
<pre class="language-julia"><code>Date(1987, 9) # year, month</code></pre>
<pre class="output"><code>1987-09-01</code></pre>
<pre class="language-julia"><code>Date(1987, 9, 13) # year, month, day</code></pre>
<pre class="output"><code>1987-09-13</code></pre>
<pre class="language-julia"><code>DateTime(1987, 9, 13, 21) # year, month, day, hour</code></pre>
<pre class="output"><code>1987-09-13T21:00:00</code></pre>
<pre class="language-julia"><code>DateTime(1987, 9, 13, 21, 21) # year, month, day, hour, minute</code></pre>
<pre class="output"><code>1987-09-13T21:21:00</code></pre>
<p>好奇的人会发现，1987 年 9 月 13 日 21 点 21 分正是第一作者 Jose 的官方出生时间。</p>
<p>也可以向默认构造器传递 <code>Period</code> 类型。 对于计算机来说，<strong><code>Period</code> 类型是时间的等价表示</strong>。 Julia 的 <code>Dates</code> 具有如下的 <code>Period</code> 抽象类型：</p>
<pre class="language-julia"><code>subtypes(Period)</code></pre>
<pre class="output"><code>DatePeriod</code></pre>
<pre class="output"><code>TimePeriod</code></pre>
<p>它被划分为如下的具体类型，并且它们的用法都是不言自明的：</p>
<pre class="language-julia"><code>subtypes(DatePeriod)</code></pre>
<pre class="output"><code>Day</code></pre>
<pre class="output"><code>Month</code></pre>
<pre class="output"><code>Quarter</code></pre>
<pre class="output"><code>Week</code></pre>
<pre class="output"><code>Year</code></pre>
<pre class="language-julia"><code>subtypes(TimePeriod)</code></pre>
<pre class="output"><code>Hour</code></pre>
<pre class="output"><code>Microsecond</code></pre>
<pre class="output"><code>Millisecond</code></pre>
<pre class="output"><code>Minute</code></pre>
<pre class="output"><code>Nanosecond</code></pre>
<pre class="output"><code>Second</code></pre>
<p>因此，也能以如下方式构造 Jose 的官方出生时间：</p>
<pre class="language-julia"><code>DateTime(Year(1987), Month(9), Day(13), Hour(21), Minute(21))</code></pre>
<pre class="output"><code>1987-09-13T21:21:00</code></pre>
<h4 data-number="3.5.1.2" id="sec:dates_parsing"><span class="header-section-number">3.5.1.2</span> 序列化 Dates</h4>
<p>多数情况下，我们不会从零开始构造 <code>Date</code> 或 <code>DateTime</code> 示例。 实际上更可能是 <strong>将字符串序列化为 <code>Date</code> 或 <code>DateTime</code> 类型</strong>。</p>
<p><code>Date</code> 和 <code>DateTime</code> 构造器可以接收一个数字字符串和格式字符串。 例如，表示 1987 年 9 月 13 日的字符串 <code>"19870913"</code> 可被序列化为：</p>
<pre class="language-julia"><code>Date(&quot;19870913&quot;, &quot;yyyymmdd&quot;)</code></pre>
<pre class="output"><code>1987-09-13</code></pre>
<p>注意第二个参数是日期格式的字符串表示。 前四位表示年 <code>y</code>，后接着的两位表示月 <code>m</code>， 而最后两位数字表示日 <code>d</code>.</p>
<p>这也适用于 <code>DateTime</code> 的时间戳：</p>
<pre class="language-julia"><code>DateTime(&quot;1987-09-13T21:21:00&quot;, &quot;yyyy-mm-ddTHH:MM:SS&quot;)</code></pre>
<pre class="output"><code>1987-09-13T21:21:00</code></pre>
<p>可以在 <a href="https://docs.julialang.org/en/v1/stdlib/Dates/#Dates.DateFormat">Julia <code>Dates</code>’ documentation</a> 了解到更多的日期格式。 不同担心需要时常浏览文档，我们在处理日期和时间戳时也是这样。</p>
<p>根据 <a href="https://docs.julialang.org/en/v1/stdlib/Dates/#Constructors">Julia <code>Dates</code>’ documentation</a>，当只需调用几次时，使用 <code>Date(date_string, format_string)</code> 方法也是可以的。 然而，如果需要处理大量相同格式的日期字符串，那么更高效的方法是先创建 <code>DateFormat</code> 类型，然后传递该类型而不是原始的格式字符串。 然后，先前的例子改为：</p>
<pre class="language-julia"><code>format = DateFormat(&quot;yyyymmdd&quot;)
Date(&quot;19870913&quot;, format)</code></pre>
<pre class="output"><code>1987-09-13</code></pre>
<p>或者，在不损失性能的情况下，使用字符串字面量前缀 <code>dateformat"..."</code>：</p>
<pre class="language-julia"><code>Date(&quot;19870913&quot;, dateformat&quot;yyyymmdd&quot;)</code></pre>
<pre class="output"><code>1987-09-13</code></pre>
<h4 data-number="3.5.1.3" id="sec:dates_information"><span class="header-section-number">3.5.1.3</span> 提取日期信息</h4>
<p>很容易 <strong>从 <code>Date</code> 和 <code>DateTime</code> 对象中提取想要的信息</strong>。 首先，创建一个具体日期的实例：</p>
<pre class="language-julia"><code>my_birthday = Date(&quot;1987-09-13&quot;)</code></pre>
<pre class="output"><code>1987-09-13</code></pre>
<p>然后可以从 <code>my_birthday</code> 中提取任何想要的信息：</p>
<pre class="language-julia"><code>year(my_birthday)</code></pre>
<pre class="output"><code>1987</code></pre>
<pre class="language-julia"><code>month(my_birthday)</code></pre>
<pre class="output"><code>9</code></pre>
<pre class="language-julia"><code>day(my_birthday)</code></pre>
<pre class="output"><code>13</code></pre>
<p>Julia 的 <code>Dates</code> 模块也提供了 <strong>返回值元组的复合函数</strong>：</p>
<pre class="language-julia"><code>yearmonth(my_birthday)</code></pre>
<pre class="output"><code>(1987, 9)</code></pre>
<pre class="language-julia"><code>monthday(my_birthday)</code></pre>
<pre class="output"><code>(9, 13)</code></pre>
<pre class="language-julia"><code>yearmonthday(my_birthday)</code></pre>
<pre class="output"><code>(1987, 9, 13)</code></pre>
<p>也能了解该日期是一周的第几天和其他方便的应用：</p>
<pre class="language-julia"><code>dayofweek(my_birthday)</code></pre>
<pre class="output"><code>7</code></pre>
<pre class="language-julia"><code>dayname(my_birthday)</code></pre>
<pre class="output"><code>Sunday</code></pre>
<pre class="language-julia"><code>dayofweekofmonth(my_birthday)</code></pre>
<pre class="output"><code>2</code></pre>
<p>是的，Jose 出生在 9 月的第 2 个星期日。</p>
<blockquote>
<p><strong><em>NOTE:</em></strong> 如下是一个从 <code>Dates</code> 实例中提取工作日的便捷提示。 对 <code>dayofweek(your_date) &lt;= 5</code> 使用 <code>filter</code>。 也可以使用 <a href="https://github.com/JuliaFinance/BusinessDays.jl"><code>BusinessDays.jl</code></a> 包进行工作日相关的操作。</p>
</blockquote>
<h4 data-number="3.5.1.4" id="sec:dates_operations"><span class="header-section-number">3.5.1.4</span> 日期操作</h4>
<p>可以对 <code>Dates</code> 实例进行多种 <strong>操作</strong> 。 例如，可以对一个 <code>Date</code> 或 <code>DateTime</code> 实例增加天数。 请注意，Julia 的 <code>Dates</code> 将自动地对闰年以及 30 天或 31 天的月份执行必要的调整(这称为 <strong>日历</strong> 算术)。</p>
<pre class="language-julia"><code>my_birthday + Day(90)</code></pre>
<pre class="output"><code>1987-12-12</code></pre>
<p>我们想加多少天就加多少天：</p>
<pre class="language-julia"><code>my_birthday + Day(90) + Month(2) + Year(1)</code></pre>
<pre class="output"><code>1989-02-11</code></pre>
<p>可能你想知道：“还能用 <code>Dates</code> 做些什么？还有哪些可用的方法？”，则可以使用 <code>methodswith</code> 检索这些方法。 这里只展示前 20 条结果：</p>
<pre class="language-julia"><code>first(methodswith(Date), 20)</code></pre>
<pre class="output"><code>[1] show(io::IO, dt::Date) in Dates at /opt/hostedtoolcache/julia/1.7.3/x64/share/julia/stdlib/v1.7/Dates/src/io.jl:736
[2] show(io::IO, ::MIME{Symbol(&quot;text/plain&quot;)}, dt::Date) in Dates at /opt/hostedtoolcache/julia/1.7.3/x64/share/julia/stdlib/v1.7/Dates/src/io.jl:734
[3] DateTime(dt::Date, t::Time) in Dates at /opt/hostedtoolcache/julia/1.7.3/x64/share/julia/stdlib/v1.7/Dates/src/types.jl:403
[4] Day(dt::Date) in Dates at /opt/hostedtoolcache/julia/1.7.3/x64/share/julia/stdlib/v1.7/Dates/src/periods.jl:36
[5] Month(dt::Date) in Dates at /opt/hostedtoolcache/julia/1.7.3/x64/share/julia/stdlib/v1.7/Dates/src/periods.jl:36
[6] Quarter(dt::Date) in Dates at /opt/hostedtoolcache/julia/1.7.3/x64/share/julia/stdlib/v1.7/Dates/src/periods.jl:36
[7] Week(dt::Date) in Dates at /opt/hostedtoolcache/julia/1.7.3/x64/share/julia/stdlib/v1.7/Dates/src/periods.jl:36
[8] Year(dt::Date) in Dates at /opt/hostedtoolcache/julia/1.7.3/x64/share/julia/stdlib/v1.7/Dates/src/periods.jl:36
[9] firstdayofmonth(dt::Date) in Dates at /opt/hostedtoolcache/julia/1.7.3/x64/share/julia/stdlib/v1.7/Dates/src/adjusters.jl:84
[10] firstdayofquarter(dt::Date) in Dates at /opt/hostedtoolcache/julia/1.7.3/x64/share/julia/stdlib/v1.7/Dates/src/adjusters.jl:157
[11] firstdayofweek(dt::Date) in Dates at /opt/hostedtoolcache/julia/1.7.3/x64/share/julia/stdlib/v1.7/Dates/src/adjusters.jl:52
[12] firstdayofyear(dt::Date) in Dates at /opt/hostedtoolcache/julia/1.7.3/x64/share/julia/stdlib/v1.7/Dates/src/adjusters.jl:119
[13] lastdayofmonth(dt::Date) in Dates at /opt/hostedtoolcache/julia/1.7.3/x64/share/julia/stdlib/v1.7/Dates/src/adjusters.jl:100
[14] lastdayofquarter(dt::Date) in Dates at /opt/hostedtoolcache/julia/1.7.3/x64/share/julia/stdlib/v1.7/Dates/src/adjusters.jl:180
[15] lastdayofweek(dt::Date) in Dates at /opt/hostedtoolcache/julia/1.7.3/x64/share/julia/stdlib/v1.7/Dates/src/adjusters.jl:68
[16] lastdayofyear(dt::Date) in Dates at /opt/hostedtoolcache/julia/1.7.3/x64/share/julia/stdlib/v1.7/Dates/src/adjusters.jl:135
[17] +(dt::Date, t::Time) in Dates at /opt/hostedtoolcache/julia/1.7.3/x64/share/julia/stdlib/v1.7/Dates/src/arithmetic.jl:19
[18] +(dt::Date, y::Year) in Dates at /opt/hostedtoolcache/julia/1.7.3/x64/share/julia/stdlib/v1.7/Dates/src/arithmetic.jl:27
[19] +(dt::Date, z::Month) in Dates at /opt/hostedtoolcache/julia/1.7.3/x64/share/julia/stdlib/v1.7/Dates/src/arithmetic.jl:54
[20] +(x::Date, y::Quarter) in Dates at /opt/hostedtoolcache/julia/1.7.3/x64/share/julia/stdlib/v1.7/Dates/src/arithmetic.jl:73</code></pre>
<p>由上可知，也能使用加 <code>+</code> 和减 <code>-</code> 运算符。 让我们看看 Jose 的年龄， 以天为单位：</p>
<pre class="language-julia"><code>today() - my_birthday</code></pre>
<pre class="output"><code>13414 days</code></pre>
<p><code>Date</code> 类型的 <strong>默认持续时间</strong> 是 <code>Day</code> 实例。 而对于 <code>DateTime</code> 类型，默认持续时间是 <code>Millisecond</code> 实例。</p>
<pre class="language-julia"><code>DateTime(today()) - DateTime(my_birthday)</code></pre>
<pre class="output"><code>1158969600000 milliseconds</code></pre>
<h4 data-number="3.5.1.5" id="sec:dates_intervals"><span class="header-section-number">3.5.1.5</span> 日期区间</h4>
<p>关于 <code>Dates</code> 模块的一个好处是，可以轻松地构造 <strong>日期和时间区间</strong>。 Julia 足够聪明，因此不用去定义在 Section <a href="/JuliaDataScience/data_structures#sec:ranges">3.3.6</a> 中讨论的整个区间类型和操作。 它只需将为 <code>range</code> 定义的函数和操作扩展到 <code>Date</code> 类型。 这就是在 <strong>为什么选择 Julia?</strong> (Section <a href="/JuliaDataScience/why_julia#sec:why_julia">2</a>) 中讨论过的多重派发。</p>
<p>例如，假设想要创建一个 <code>Day</code> 区间。 这可以轻松地通过冒号 <code>:</code> 运算符实现：</p>
<pre class="language-julia"><code>Date(&quot;2021-01-01&quot;):Day(1):Date(&quot;2021-01-07&quot;)</code></pre>
<pre class="output"><code>2021-01-01</code></pre>
<pre class="output"><code>2021-01-02</code></pre>
<pre class="output"><code>2021-01-03</code></pre>
<pre class="output"><code>2021-01-04</code></pre>
<pre class="output"><code>2021-01-05</code></pre>
<pre class="output"><code>2021-01-06</code></pre>
<pre class="output"><code>2021-01-07</code></pre>
<p>使用 <code>Day(1)</code> 作为间隔没有什么特别的， 可以使用 <strong>任意的 <code>Period</code> 类型</strong> 作为间隔。 比如，使用 3 天作为间隔：</p>
<pre class="language-julia"><code>Date(&quot;2021-01-01&quot;):Day(3):Date(&quot;2021-01-07&quot;)</code></pre>
<pre class="output"><code>2021-01-01</code></pre>
<pre class="output"><code>2021-01-04</code></pre>
<pre class="output"><code>2021-01-07</code></pre>
<p>又或者是月份：</p>
<pre class="language-julia"><code>Date(&quot;2021-01-01&quot;):Month(1):Date(&quot;2021-03-01&quot;)</code></pre>
<pre class="output"><code>2021-01-01</code></pre>
<pre class="output"><code>2021-02-01</code></pre>
<pre class="output"><code>2021-03-01</code></pre>
<p>注意， <strong>这个区间的类型是内含 <code>Date</code> 和具体 <code>Period</code> 类型的<code>StepRange</code></strong>，其中 <code>Period</code> 用于作为间隔：</p>
<pre class="language-julia"><code>date_interval = Date(&quot;2021-01-01&quot;):Month(1):Date(&quot;2021-03-01&quot;)
typeof(date_interval)</code></pre>
<pre class="output"><code>StepRange{Date, Month}</code></pre>
<p>可以使用 <code>collect</code> 函数将它转换为 <strong>向量</strong> ：</p>
<pre class="language-julia"><code>collected_date_interval = collect(date_interval)</code></pre>
<pre class="output"><code>2021-01-01</code></pre>
<pre class="output"><code>2021-02-01</code></pre>
<pre class="output"><code>2021-03-01</code></pre>
<p>并具有全部的<strong>可用数组功能</strong>，例如索引：</p>
<pre class="language-julia"><code>collected_date_interval[end]</code></pre>
<pre class="output"><code>2021-03-01</code></pre>
<p>也可以在 <code>Date</code> 向量中实现 <strong>日期操作的广播</strong> ：</p>
<pre class="language-julia"><code>collected_date_interval .+ Day(10)</code></pre>
<pre class="output"><code>2021-01-11</code></pre>
<pre class="output"><code>2021-02-11</code></pre>
<pre class="output"><code>2021-03-11</code></pre>
<p>同理，这些例子也适用于 <code>DateTime</code> 类型。</p>
<h3 data-number="3.5.2" id="sec:random"><span class="header-section-number">3.5.2</span> 随机数</h3>
<p><code>Random</code> 模块是另一重要的 Julia 标准库模块。 这个模块的用途是 <strong>生成随机数</strong>。 <code>Random</code> 是功能丰富的库，如果感兴趣，可以阅读查看 <a href="https://docs.julialang.org/en/v1/stdlib/Random/">Julia’s <code>Random</code> documentation</a> 了解更多信息。 接下来 <strong>只</strong> 讨论三个函数： <code>rand</code>， <code>randn</code> 和 <code>seed!</code>。</p>
<p>在开始前，首先导入 <code>Random</code> 模块。 先精确地导入想使用的方法：</p>
<pre class="julia"><code>using Random: seed!</code></pre>
<p>主要有 <strong>两个生成随机数的函数</strong>：</p>
<ul>
<li><code>rand</code>: 在某种数据结构或类型的 <strong>元素</strong> 中做随机抽样。</li>
<li><code>randn</code>: 在<strong>标准正态分布</strong>（平均值 0 和标准差 1）中做随机抽样。</li>
</ul>
<h4 data-number="3.5.2.1" id="sec:random_rand"><span class="header-section-number">3.5.2.1</span> <code>rand</code></h4>
<p>默认情况下，可以不带参数地调用 <code>rand</code> ，那么它就会返回一个位于区间 <span class="math inline">\([0, 1)\)</span> 的 <code>Float64</code> 随机数，该区间表示随机数的范围是 0 （包含）到 1 （排除）之间：</p>
<pre class="language-julia"><code>rand()</code></pre>
<pre class="output"><code>0.6070024145662858</code></pre>
<p>可以使用多种方式更新 <code>rand</code> 的参数。 假设，想要获得多个随机数：</p>
<pre class="language-julia"><code>rand(3)</code></pre>
<pre class="output"><code>[0.5487241005162437, 0.2083075356176668, 0.3643483123672302]</code></pre>
<p>或者，想在不同的区间抽样：</p>
<pre class="language-julia"><code>rand(1.0:10.0)</code></pre>
<pre class="output"><code>8.0</code></pre>
<p>也可以给区间指定步长，甚至可以在不同的类型间抽样。 这里使用不带点 <code>.</code> 的数字，所以 Julia 会将它们解释为 <code>Int64</code> 而不是 <code>Float64</code>：</p>
<pre class="language-julia"><code>rand(2:2:20)</code></pre>
<pre class="output"><code>14</code></pre>
<p>还可以组合和匹配参数：</p>
<pre class="language-julia"><code>rand(2:2:20, 3)</code></pre>
<pre class="output"><code>[6, 12, 10]</code></pre>
<p>它还支持元素集构成的元组：</p>
<pre class="language-julia"><code>rand((42, &quot;Julia&quot;, 3.14))</code></pre>
<pre class="output"><code>Julia</code></pre>
<p>也支持数组：</p>
<pre class="language-julia"><code>rand([1, 2, 3])</code></pre>
<pre class="output"><code>2</code></pre>
<p>还可以是 <code>Dict</code>：</p>
<pre class="language-julia"><code>rand(Dict(:one =&gt; 1, :two =&gt; 2))</code></pre>
<pre class="output"><code>:one =&gt; 1</code></pre>
<p>最后要讨论的 <code>rand</code> 参数选项是，使用数字元组指定随机数的维度。 如果执行此操作，那么返回类型将会变为数组。 例如，如下是由 1.0-3.0 间的 <code>Float64</code> 随机数构成的 2x2 矩阵：</p>
<pre class="language-julia"><code>rand(1.0:3.0, (2, 2))</code></pre>
<pre class="output"><code>2×2 Matrix{Float64}:
 3.0  2.0
 3.0  3.0</code></pre>
<h4 data-number="3.5.2.2" id="sec:random_randn"><span class="header-section-number">3.5.2.2</span> <code>randn</code></h4>
<p><code>randn</code> 遵循与 <code>rand</code> 相同的生成原理，但现在它只返回从 <strong>标准正态分布</strong> 中生成的随机数。 标准正态分布是平均值为 0 和标准差为 1 的正态分布。 其默认类型为 <code>Float64</code>，并且只接受 <code>AbstractFloat</code> 或 <code>Complex</code> 的子类型：</p>
<pre class="language-julia"><code>randn()</code></pre>
<pre class="output"><code>0.21451483896752419</code></pre>
<p>可以仅指定大小：</p>
<pre class="language-julia"><code>randn((2, 2))</code></pre>
<pre class="output"><code>2×2 Matrix{Float64}:
 -0.471473  -0.59437
  0.684233   0.286052</code></pre>
<h4 data-number="3.5.2.3" id="sec:random_seed"><span class="header-section-number">3.5.2.3</span> <code>seed!</code></h4>
<p>在 <code>Random</code> 概述的结尾部分， 我们接下来讨论 <strong>重现性</strong>。 我们经常需要让某些事能够 <strong>可复现</strong>。 这意味着，随机数生成器要每次 <strong>生成相同的随机数序列</strong>。 这可以通过 <code>seed!</code> 函数实现：</p>
<pre class="language-julia"><code>seed!(123)
rand(3)</code></pre>
<pre class="output"><code>[0.521213795535383, 0.5868067574533484, 0.8908786980927811]</code></pre>
<pre class="language-julia"><code>seed!(123)
rand(3)</code></pre>
<pre class="output"><code>[0.521213795535383, 0.5868067574533484, 0.8908786980927811]</code></pre>
<p>在一些例子中，在脚本开头调用 <code>seed!</code> 是不够好的。 为了避免 <code>rand</code> 或 <code>randn</code> 依赖全局变量，那么可以转而定义一个 <code>seed!</code> 的实例，然后将它传递给 <code>rand</code> 或 <code>randn</code> 的第一个参数。</p>
<pre class="language-julia"><code>my_seed = seed!(123)</code></pre>
<pre class="output"><code>Random.TaskLocalRNG()</code></pre>
<pre class="language-julia"><code>rand(my_seed, 3)</code></pre>
<pre class="output"><code>[0.521213795535383, 0.5868067574533484, 0.8908786980927811]</code></pre>
<pre class="language-julia"><code>randn(my_seed, 3)</code></pre>
<pre class="output"><code>[-0.21766510678354617, 0.4922456865251828, 0.9809798121241488]</code></pre>
<blockquote>
<p><strong><em>NOTE:</em></strong> 请注意，对于不同的版本，这些数字可能会有所不同。 若要在不同的版本获得稳定的随机数流，请使用 <code>StableRNGs.jl</code> 库。</p>
</blockquote>
<h3 data-number="3.5.3" id="sec:downloads"><span class="header-section-number">3.5.3</span> Downloads</h3>
<p>最后一个要讨论的 Julia 标准库是 <strong><code>Downloads</code> 模块</strong>。 这部分相当简短，因为只关注单个函数 <code>download</code>。</p>
<p>假设想要 <strong>从互联网上下载文件到本地</strong>。 这可以用通过 <code>download</code> 函数实现。 最简单情况下，仅仅需要一个参数，那就是文件的 url。 还可以指定第二个参数作为下载文件的输出路径 (不要忘记文件系统的最佳实践!)。 如果不指定第二个参数，默认情况下，Julia 将使用 <code>tempfile</code> 函数创建一个临时文件。</p>
<p>首先导入 <code>Downloads</code> 模块：</p>
<pre class="julia"><code>using Downloads</code></pre>
<p>例如，下载 <a href="https://github.com/JuliaDataScience/JuliaDataScience"><code>JuliaDataScience</code> GitHub 仓库</a> 的 <code>Project.toml</code> 文件。 注意，<code>Downloads</code> 模块并没有导出 <code>download</code> 函数，因此需要使用语法 <code>Module.function</code> 。 默认情况下， 它返回一个包含下载文件本地路径的字符串：</p>
<pre class="language-julia"><code>url = &quot;https://raw.githubusercontent.com/JuliaDataScience/JuliaDataScience/main/Project.toml&quot;

my_file = Downloads.download(url) # tempfile() being created</code></pre>
<pre class="output"><code>/tmp/jl_sDlBE4</code></pre>
<p>可以使用 <code>readlines</code> 查看下载文件的前四行：</p>
<pre class="language-julia"><code>readlines(my_file)[1:4]</code></pre>
<pre class="output"><code>4-element Vector{String}:
 &quot;name = \&quot;JDS\&quot;&quot;
 &quot;uuid = \&quot;6c596d62-2771-44f8-8373-3ec4b616ee9d\&quot;&quot;
 &quot;authors = [\&quot;Jose Storopoli\&quot;, \&quot;Rik Huijzer\&quot;, \&quot;Lazaro Alonso\&quot;]&quot;
 &quot;&quot;</code></pre>
<blockquote>
<p><strong><em>NOTE:</em></strong> 对于更复杂的 HTTP 交互过程，例如与 web API 交互，请使用 <a href="https://github.com/JuliaWeb/HTTP.jl"><code>HTTP.jl</code></a> 包。</p>
</blockquote>


<div class="bottom-nav">
    <p id="nav-prev" style="text-align: left;">
        <a class="menu-level-2" href="/JuliaDataScience/filesystem"><b>3.4</b> 文件系统</a> <kbd>←</kbd>
        <span id="nav-next" style="float: right;">
            <kbd>→</kbd> <a class="menu-level-1" href="/JuliaDataScience/dataframes"><b>4</b> DataFrames.jl</a>
        </span>
    </p>
</div>


<div class="license">
    <br/>
  <br/>
  <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a>
    Jose Storopoli, Rik Huijzer, Lazaro Alonso, 刘贵欣 (中文翻译), 田俊 （中文审校）
</div>
</div>
</div>
</body>
</html>