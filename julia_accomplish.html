<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US" xml:lang="en-US">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Jose Storopoli" />
  <meta name="author" content="Rik Huijzer" />
  <meta name="author" content="Lazaro Alonso" />
  <meta name="author" content="刘贵欣 (中文翻译)" />
  <meta name="author" content="田俊 （中文审校）" />
  <title>Julia 想实现什么? - Julia Data Science</title>
  <link rel="shortcut icon" type="image/png" href="/JuliaDataScience/favicon.png"/>
  <link rel="stylesheet" href="/JuliaDataScience/style.css"/>
    <script src="/JuliaDataScience/mousetrap.min.js"></script>
    <style>
  @font-face {
    font-family: JuliaMono-Regular;
    src: url("/JuliaDataScience/JuliaMono-Regular.woff2");
  }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>
  <link rel="stylesheet" href="/JuliaDataScience/github.min.css">
<script src="/JuliaDataScience/highlight.min.js"></script>
<script src="/JuliaDataScience/julia.min.js"></script>
<script>
document.addEventListener('DOMContentLoaded', (event) => {
    document.querySelectorAll('pre').forEach((el) => {
        hljs.highlightElement(el);
    });
});
</script>
 
</head>
<body>
<script>
function click_next() {
  var next = document.getElementById('nav-next');
  next.firstElementChild.nextElementSibling.click();
}
function click_prev() {
  var prev = document.getElementById('nav-prev');
  prev.firstElementChild.click();
}
Mousetrap.bind('right', click_next);
Mousetrap.bind('h', click_prev);
Mousetrap.bind('left', click_prev);
Mousetrap.bind('l', click_next);
</script>

<div class="books-container">
<aside class="books-menu">
<input type="checkbox" id="menu">
<label for="menu">☰</label>
<div class="books-title">
<a href="/JuliaDataScience/">Julia Data Science</a>
</div><br />
<span class="books-subtitle">

</span>
<div class="books-menu-content">
<li><a class="menu-level-1" href="/JuliaDataScience/preface"><b>1</b> 前言</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/why_data_science"><b>1.1</b> 什么是数据科学？</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/engineering"><b>1.2</b> 软件工程</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/acknowledgements"><b>1.3</b> 致谢</a></li>
<li><a class="menu-level-1" href="/JuliaDataScience/why_julia"><b>2</b> 为什么选择 Julia ?</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/non-programmers"><b>2.1</b> 从未编过程</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/programmers"><b>2.2</b> 有编程经验</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/julia_accomplish"><b>2.3</b> Julia 想实现什么?</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/julia_wild"><b>2.4</b> Julia 应用案例</a></li>
<li><a class="menu-level-1" href="/JuliaDataScience/julia_basics"><b>3</b> Julia 基础</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/ide"><b>3.1</b> 开发环境</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/syntax"><b>3.2</b> 语法</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/data_structures"><b>3.3</b> 原生数据结构</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/filesystem"><b>3.4</b> 文件系统</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/standardlibrary"><b>3.5</b> Julia 标准库</a></li>
<li><a class="menu-level-1" href="/JuliaDataScience/dataframes"><b>4</b> DataFrames.jl</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/load_save"><b>4.1</b> 加载和保存文件</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/index_summarize"><b>4.2</b> Index 和 Summarize</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/filter_subset"><b>4.3</b> Filter 和 Subset</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/select"><b>4.4</b> Select</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/missing_data"><b>4.5</b> 类型和缺失值</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/join"><b>4.6</b> Join</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/df_transform"><b>4.7</b> 变量变换</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/groupby_combine"><b>4.8</b> Groupby 和 Combine</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/df_performance"><b>4.9</b> 性能</a></li>
<li><a class="menu-level-1" href="/JuliaDataScience/DataVisualizationMakie"><b>5</b> 使用 Makie.jl 做数据可视化</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/cairomakie"><b>5.1</b> CairoMakie.jl</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/datavisMakie_attributes"><b>5.2</b> 属性</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/themes"><b>5.3</b> 主题</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/using_latex"><b>5.4</b> 使用 LaTeXStrings.jl</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/makie_colors"><b>5.5</b> 颜色和颜色图（Colormap）</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/makie_layouts"><b>5.6</b> 布局</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/glmakie"><b>5.7</b> GLMakie.jl</a></li>
<li><a class="menu-level-1" href="/JuliaDataScience/appendix"><b>6</b> 附录</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/appendix_pkg"><b>6.1</b> 库的版本</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/notation"><b>6.2</b> 符号</a></li>
<li><a class="menu-level-1" href="/JuliaDataScience/references"><b></b> 参考文献</a></li>
</div>
</aside>

<div class="books-content">
<h2 data-number="2.3" id="sec:julia_accomplish"><span class="header-section-number">2.3</span> Julia 想实现什么?</h2>
<blockquote>
<p><strong><em>NOTE:</em></strong> 本节将详细解释是什么使 Julia 成为一门出色的编程语言。 如果这对你来说太过技术性，你可以跳过这节并前往 Section <a href="/JuliaDataScience/dataframes#sec:dataframes">4</a> 学习如何使用 <code>DataFrames.jl</code> 处理表格数据。</p>
</blockquote>
<p>Julia 编程语言 <span class="citation" data-cites="bezanson2017julia">(<a href="/JuliaDataScience/references#ref-bezanson2017julia" role="doc-biblioref">Bezanson et al., 2017</a>)</span> 是一门较新的语言，第一版发布于 2012 年，其目标是 <strong>简单且快速</strong>。 即，“ 运行起来像C<a href="/JuliaDataScience#fn8" class="footnote-ref" id="fnref8" role="doc-noteref"><sup>8</sup></a>， 但阅读起来像 Python”<span class="citation" data-cites="perkelJuliaComeSyntax2019">(<a href="/JuliaDataScience/references#ref-perkelJuliaComeSyntax2019" role="doc-biblioref">Perkel, 2019</a>)</span>。 它是为科学计算设计的，能够处理 <strong>大规模的数据与计算</strong> 。但仍可以相当 <strong>容易地创建和操作原型代码</strong>。</p>
<p>Julia 的创始人在一篇<a href="https://julialang.org/blog/2012/02/why-we-created-julia/">2012 年的博客</a> 中解释了为什么要创造 Julia。 他们说<a href="/JuliaDataScience#fn9" class="footnote-ref" id="fnref9" role="doc-noteref"><sup>9</sup></a>：</p>
<blockquote>
<p>我们很贪婪：我们想要更多。 我们想要一门采用自由许可证的开源语言。 我们想要 C 的性能和 Ruby 的动态特性。 我们想要一门同调的语言，它既拥有 Lisp 那样真正的宏， 但又具有 Matlab 那样明显又熟悉的数学运算符。 我们希望这门语言可以像 Python 一样用于常规编程，像 R 一样容易地用于统计领域，像 Perl 一样自然地处理字符串，像 Matlab 一样拥有强大的线性代数系统，像 Shell 一样能够擅长组合程序。 这门语言要简单易学，但又能打动最认真的极客。 我们希望它可交互，同时希望它是编译的。</p>
</blockquote>
<p>大多数用户都被 Julia 的 <strong>优越速度</strong> 所吸引。 毕竟，Julia 可是著名独家俱乐部 petaflop 的成员。 <a href="https://www.hpcwire.com/off-the-wire/julia-joins-petaflop-club/"><strong>petaflop 俱乐部</strong></a> 的组成成员都是一些峰值运算速度超过 <strong>千万亿次每秒</strong> 的编程语言。 现在只有 C，C++，Fortran，和 Julia 属于 <a href="https://www.nextplatform.com/2017/11/28/julia-language-delivers-petascale-hpc-performance/">petaflop 俱乐部</a>。</p>
<p>但是，速度不是 Julia 的全部。 Julia 的一些特性还包括<strong>易用性</strong>、 <strong>Unicode 支持</strong> 和 <strong>代码共享的便捷性</strong>。 本节将讨论这些所有的特性，不过目前先来关注 Julia 的代码共享特性。</p>
<p>Julia 软件包的生态非常独特。 它不仅允许共享代码，也允许共享用户自定义的类型。 例如，Python 的 <code>pandas</code> 使用自带的 <code>Datetime</code> 类型来处理日期。 同时， R tidyverse 的 <code>lubridate</code> 包也使用自定义的 <code>datetime</code> 类型来处理日期。 Julia 不需要上述任何一种类型, 因为其标准库已准备好了所有的日期工具。 这意味其他包不需要担心日期处理。 其他包仅需要为 Julia <code>DateTime</code> 类型扩展新功能，即定义新函数但不需要定义新类型。 Julia <code>Dates</code> 模块可以实现许多令人惊叹的功能，但目前讨论它有些超前。 于是让我们来讨论一些 Julia 的其他特性。</p>
<h3 data-number="2.3.1" id="julia-vs-其他编程语言"><span class="header-section-number">2.3.1</span> Julia VS 其他编程语言</h3>
<p>图 <a href="/JuliaDataScience#fig:language_comparison">2</a> 给出了非常个性化的分类，它将主流的开源科学计算编程语言分在一张 2x2 图中， 该图具有两个轴： <strong>Slow-Fast（慢-快）</strong> 和 <strong>Easy-Hard（简单-困难）</strong>。 我们省略了闭源语言，因为允许其他人运行你的代码以及检查源代码中的问题会具有许多好处。</p>
<p>我们把 C++ 和 FORTRAN 放在 困难-快 象限。 作为需要编译、类型检查和其他专业管理的静态语言，它们真的很难学习，原型代码也编写很缓慢。 好处是它们都是 <strong>非常快的</strong> 语言。</p>
<p>R 和 Python 放在 简单-慢 象限。 它们是不需要编译的动态语言，在运行时执行。 因此，它们很容易学习，能够快速创建原型代码。 当然，这会导致共同的缺点： 它们都是 <strong>非常慢的</strong> 语言。</p>
<p>Julia 是唯一一门在 简单-快 象限的语言。 我们知道任何其他严格的语言都不会想变得困难且缓慢，所以此象限为空。</p>
<figure>
<img src="images/language_comparisons.png" id="fig:language_comparison" alt="Figure 2: 科学计算编程语言比较：FORTRAN、C++、Python、R 和 Julia。" /><figcaption aria-hidden="true">Figure 2: 科学计算编程语言比较：FORTRAN、C++、Python、R 和 Julia。</figcaption>
</figure>
<p><strong>Julia 很快! 特别快!</strong> 它起初就为速度而设计。 而这通过多重派发实现。 基本上，这个想法能够生成非常高效的 LLVM<a href="/JuliaDataScience#fn10" class="footnote-ref" id="fnref10" role="doc-noteref"><sup>10</sup></a> 代码。 LLVM 代码，也称为 LLVM 指令，它非常靠近底层，即非常接近计算机执行的实际操作。 所以，本质上， Julia 会将你可读性好的手写代码转换为 LLVM 机器码。虽然 LLVM 机器码对于人类来说很难阅读，但对于计算机来说很容易。 例如，如果你定义了一个接收单个参数的函数并向该函数传递整数，然后 Julia 会创建一个 <strong>专门的</strong> <code>MethodInstance</code>。 下次你再向该函数传递整数时，Julia 将会查找之前创建的 <code>MethodInstance</code>，并引用其执行操作。 一个<strong>很棒的</strong> 技巧是，可以在调用函数的嵌套函数中使用它。 例如，如果向函数 <code>f</code> 传递了某些数据类型，而 <code>f</code> 又调用了函数 <code>g</code>，同时传递给 <code>g</code> 的数据类型都是相同且已知的，那么生成函数 <code>g</code> 就会硬编码到 <code>f</code> 中！ 这意味着 Julia 不再需要查找 <code>MethodInstances</code>，此时代码就会运行地非常快。 此处需要权衡的是，在某些情况下，早期关于硬编码 <code>MethodInstances</code> 的假设可能是无效的。 然后需要重新创建硬编码的 <code>MethodInstances</code>。 因此，权衡也需包括花时间推断哪些能够硬编码，而哪些不能。 这也解释了为什么 Julia 代码在第一次执行前通常要花费较长的时间： Julia 在背后优化代码。</p>
<p>编译器接着做它最擅长的事情：优化机器码<a href="/JuliaDataScience#fn11" class="footnote-ref" id="fnref11" role="doc-noteref"><sup>11</sup></a>。 你可以在 Julia 网站上找到 Julia 和其他语言的 <a href="https://julialang.org/benchmarks/">benchmarks</a> 。 图 <a href="/JuliaDataScience#fig:benchmarks">3</a> 取自于 <a href="https://julialang.org/benchmarks/">Julia 网站的 benchmarks 节<a href="/JuliaDataScience#fn12" class="footnote-ref" id="fnref12" role="doc-noteref"><sup>12</sup></a></a>。 如你所见， Julia 是<strong>相当</strong> 快的。</p>
<figure>
<img src="images/benchmarks.png" id="fig:benchmarks" alt="Figure 3: Julia VS 其他编程语言。" /><figcaption aria-hidden="true">Figure 3: Julia VS 其他编程语言。</figcaption>
</figure>
<p>我们非常信任 Julia。 否则，我们不会写这本书。 我们认为， Julia 是 <strong>科学计算和科学数据分析的未来</strong>。 它使得用户可以通过简单的语法开发快速且强大的代码。 研究人员通常使用一种简单但缓慢的语言开发原型代码。 一旦确定代码正常运行且实现其目标，然后就会开始将当前的代码转换为一门快速但困难的编程语言。 这就是“两语言问题”，接下来将讨论它。</p>
<h3 data-number="2.3.2" id="sec:two_language"><span class="header-section-number">2.3.2</span> 两语言问题</h3>
<p>“两语言问题” 是科学计算中的典型问题。通常研究人员想要设计一种算法或方案来解决手头的问题或分析。 一般地，解决方案的原型代码都采用容易编程的语言（像 Python 或 R）。 如果原型能够正常工作，那么研究人员就会使用不易编写原型但快速的语言（C++ 或 FORTRAN）重新实现。 因此，开发解决方案的过程涉及了两种语言。 一种语言易于编写原型代码并不适合方案实现 (通常由于缓慢的速度)。 而另一种语言并不易于编写原型代码，但由于非常快，所以适合方案实现。 Julia 能够避免此类情形，因为 <strong>开发原型（易编程）和方案实现（速度快）将采用相同的语言</strong>。</p>
<p>另外， Julia 允许使用 <strong>Unicode 字符作为变量或参数</strong>。 这意味着不再使用 <code>sigma</code> 或 <code>sigma_i</code>，而是像数学记号那样使用 <span class="math inline">\(σ\)</span> 或 <span class="math inline">\(σᵢ\)</span> 。 当查看算法代码或数学方程时，你会看到几乎相同的符号和术语。 我们将这种强大的特性称为 <strong>“代码和数学关系的一对一”</strong>。</p>
<p>我们认为，Alan Edelman，Julia 创始人之一，在一次<a href="https://youtu.be/qGW0GT1rCvs">TEDx Talk</a> <span class="citation" data-cites="tedxtalksProgrammingLanguageHeal2020">(<a href="/JuliaDataScience/references#ref-tedxtalksProgrammingLanguageHeal2020" role="doc-biblioref">TEDx Talks, 2020</a>)</span> 中对 “两语言问题” 和 “代码和数学关系的一对一” 作出了最好的描述。</p>
<style>.embed-container { position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden; max-width: 100%; } .embed-container iframe, .embed-container object, .embed-container embed { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }</style>
<div class="embed-container">
<iframe src="https://www.youtube.com/embed/qGW0GT1rCvs" frameborder="0" allowfullscreen>
</iframe>
</div>
<h3 data-number="2.3.3" id="sec:multiple_dispatch"><span class="header-section-number">2.3.3</span> 多重派发</h3>
<p>多重派发（multiple dispatch）是一种强大的特性，它使得能够扩展现有的函数或为新类型自定义复杂行为。 假设想要定义两种 <code>struct</code> 来表示不同的动物：</p>
<pre class="language-julia"><code>abstract type Animal end
struct Fox &lt;: Animal
    weight::Float64
end
struct Chicken &lt;: Animal
    weight::Float64
end</code></pre>
<p>这表明此处定义了动物类型 <code>Fox</code> 和 <code>Chicken</code>。 然后生成名为 Fiona 的 <code>Fox</code> 和名为 Big Bird 的 <code>Chicken</code>。</p>
<pre class="language-julia"><code>fiona = Fox(4.2)
big_bird = Chicken(2.9)</code></pre>
<p>为了知道他们的重量之和，编写如下的函数：</p>
<pre class="language-julia"><code>combined_weight(A1::Animal, A2::Animal) = A1.weight + A2.weight</code></pre>
<pre class="output"><code>combined_weight (generic function with 1 method)</code></pre>
<p>然后还想知道它们能否相处得好。 采用条件语句实现：</p>
<pre class="language-julia"><code>function naive_trouble(A::Animal, B::Animal)
    if A isa Fox &amp;&amp; B isa Chicken
        return true
    elseif A isa Chicken &amp;&amp; B isa Fox
        return true
    elseif A isa Chicken &amp;&amp; B isa Chicken
        return false
    end
end</code></pre>
<pre class="output"><code>naive_trouble (generic function with 1 method)</code></pre>
<p>现在，看看 Fiona 和 Big Bird 待在一起是否会产生麻烦：</p>
<pre class="language-julia"><code>naive_trouble(fiona, big_bird)</code></pre>
<pre class="output"><code>true</code></pre>
<p>好的，看起来不错。 编写 <code>naive_trouble</code> 函数已经足够简单了。然而，使用多重派发编写 <code>trouble</code> 函数还可以带来新的优势。按照如下方式创建函数：</p>
<pre class="language-julia"><code>trouble(F::Fox, C::Chicken) = true
trouble(C::Chicken, F::Fox) = true
trouble(C1::Chicken, C2::Chicken) = false</code></pre>
<pre class="output"><code>trouble (generic function with 3 methods)</code></pre>
<p>定义这些方法后，<code>trouble</code> 会得到与 <code>naive_trouble</code> 相同的结果。 例如：</p>
<pre class="language-julia"><code>trouble(fiona, big_bird)</code></pre>
<pre class="output"><code>true</code></pre>
<p>把 Big Bird 和另外一只小鸡 Dora 放在一起也是可以的。</p>
<pre class="language-julia"><code>dora = Chicken(2.2)
trouble(dora, big_bird)</code></pre>
<pre class="output"><code>false</code></pre>
<p>所以在本例中，多重派发的优势就是可以仅声明类型，然后由 Julia 去为类型找到正确的函数方法。 若是在嵌套函数中使用多重派发则更是如此，Julia 编译器实际上会自动优化函数调用。 例如，函数如下：</p>
<pre><code>function trouble(A::Fox, B::Chicken, C::Chicken)
    return trouble(A, B) || trouble(B, C) || trouble(C, A)
end</code></pre>
<p>根据上下文，Julia 会将其优化为：</p>
<pre><code>function trouble(A::Fox, B::Chicken, C::Chicken)
    return true || false || true
end</code></pre>
<p>因为编译器 <strong>知道</strong> <code>A</code> 是 <code>Fox</code>, <code>B</code> 是 <code>Chicken</code> ，所以方法替换为 <code>trouble(F::Fox, C::Chicken)</code>。 <code>trouble(C1::Chicken, C2::Chicken)</code> 同理。 然后，编译器进一步优化：</p>
<pre><code>function trouble(A::Fox, B::Chicken, C::Chicken)
    return true
end</code></pre>
<p>此外，多重派发还使比较已存在的动物和新的动物 Zebra 成为可能。 可以在其他包中定义 Zebra ：</p>
<pre class="language-julia"><code>struct Zebra &lt;: Animal
    weight::Float64
end</code></pre>
<p>然后定义与现有动物的交互：</p>
<pre class="language-julia"><code>trouble(F::Fox, Z::Zebra) = false
trouble(Z::Zebra, F::Fox) = false
trouble(C::Chicken, Z::Zebra) = false
trouble(Z::Zebra, F::Fox) = false</code></pre>
<pre class="output"><code>trouble (generic function with 6 methods)</code></pre>
<p>现在可查看 Marty（Zebra 动物）是否能与 Big Bird 和谐相处：</p>
<pre class="language-julia"><code>marty = Zebra(412)
trouble(big_bird, marty)</code></pre>
<pre class="output"><code>false</code></pre>
<p>更好的是，<strong>不需额外定义任何函数即可计算 Zebra 和其他动物的重量之和</strong>：</p>
<pre class="language-julia"><code>combined_weight(big_bird, marty)</code></pre>
<pre class="output"><code>414.9</code></pre>
<p>因此，总而言之，即使在编写代码时只考虑了 <code>Fox</code> 和 <code>Chicken</code>，但它也能用于 <strong>从未见过的</strong> 类型！ 在实践中，这意味着重用其他 Julia 项目的代码会非常容易。</p>
<p>如果你和我们一样对多重派发感到兴奋，那么可以了解下面这些深入的例子。 第一个例子是，<span class="citation" data-cites="storopoli2021bayesianjulia"><a href="/JuliaDataScience/references#ref-storopoli2021bayesianjulia" role="doc-biblioref">Storopoli</a> (<a href="/JuliaDataScience/references#ref-storopoli2021bayesianjulia" role="doc-biblioref">2021</a>)</span> 关于 <a href="https://storopoli.io/Bayesian-Julia/pages/1_why_Julia/#example_one-hot_vector">one-hot 向量的快速而优雅的实现</a> 。 第二个例子是，<a href="https://youtu.be/moyPIhvw4Nk?t=2107">Tanmay Bakshi YouTube 频道</a> 对 <a href="https://www.chrisrackauckas.com/">Christopher Rackauckas</a> 的采访 （查看时间 35:07 ） <span class="citation" data-cites="tanmaybakshiBakingKnowledgeMachine2021">(<a href="/JuliaDataScience/references#ref-tanmaybakshiBakingKnowledgeMachine2021" role="doc-biblioref">tanmay bakshi, 2021</a>)</span>。 Chris 提到， 在他开发和维护 <a href="https://diffeq.sciml.ai/dev/"><code>DifferentialEquations.jl</code></a> 包时，一名用户报告问题说：他基于 GPU 构造的 ODE 求解器并不能正常工作。 Chris 对这个请求感到非常惊讶，因为他从来没有期望能够将 GPU 计算与求解边界值问题结合起来。 他甚至更惊讶地发现，用户犯了一个小错误，但一切正常。 这些大多数优点都来自于多重派发和高可用的代码 / 类型共享。</p>
<p>总的来说，我们认为多重派发的最好解释来自于 Julia 创始人 <a href="https://youtu.be/kc9HwsxE1OY">Stefan Karpinski 在 JuliaCon 2019 的演讲</a>。</p>
<style>.embed-container { position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden; max-width: 100%; } .embed-container iframe, .embed-container object, .embed-container embed { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }</style>
<div class="embed-container">
<iframe src="https://www.youtube.com/embed/kc9HwsxE1OY" frameborder="0" allowfullscreen>
</iframe>
</div>


<div class="bottom-nav">
    <p id="nav-prev" style="text-align: left;">
        <a class="menu-level-2" href="/JuliaDataScience/programmers"><b>2.2</b> 有编程经验</a> <kbd>←</kbd>
        <span id="nav-next" style="float: right;">
            <kbd>→</kbd> <a class="menu-level-2" href="/JuliaDataScience/julia_wild"><b>2.4</b> Julia 应用案例</a>
        </span>
    </p>
</div>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn8" role="doc-endnote"><p> 8. 有时甚至快于C。<a href="/JuliaDataScience#fnref8" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn9" role="doc-endnote"><p> 9. 译者注：这段话的翻译参考了 InfoQ 的文章 “再见 Python，你好 Julia!”。<a href="/JuliaDataScience#fnref9" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn10" role="doc-endnote"><p> 10. LLVM 是 <strong>L</strong>ow <strong>L</strong>evel <strong>V</strong>irtual <strong>M</strong>chine 的缩写，你可以在LLVM 网站(<a href="http://llvm.org" class="uri">http://llvm.org</a>)找到更多信息。<a href="/JuliaDataScience#fnref10" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn11" role="doc-endnote"><p> 11. 如果你想了解更多关于 Julia 如何设计的内容，你绝对需要看 <span class="citation" data-cites="bezanson2017julia"><a href="/JuliaDataScience/references#ref-bezanson2017julia" role="doc-biblioref">Bezanson et al.</a> (<a href="/JuliaDataScience/references#ref-bezanson2017julia" role="doc-biblioref">2017</a>)</span> 。<a href="/JuliaDataScience#fnref11" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn12" role="doc-endnote"><p> 12. 请注意上述的 Julia 结果不包含编译时间。<a href="/JuliaDataScience#fnref12" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>


<div class="license">
    <br/>
  <br/>
  <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a>
    Jose Storopoli, Rik Huijzer, Lazaro Alonso, 刘贵欣 (中文翻译), 田俊 （中文审校）
</div>
</div>
</div>
</body>
</html>